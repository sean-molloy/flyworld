 // room script file
bool allowScroll = true;
int wayForward;
bool followScrollLock = false;
int camPositionLock;
bool allowFollowScroll = true;

float calculateScrollSpeed(int diff)
{
  if (diff > 340)
  {
    return 11.0;
  }  else if(diff > 300)
  {
    return 10.0;
  } else if (diff > 250)
  {
    return 6.0;
  } else if (diff > 200)
  {
    return 5.0;
  } else if (diff > 150)
  {
    return 4.0;
  } else if (diff > 100)
  {
    return 3.0;
  } else if (diff > 50)
  {
    return 2.0;
  }  else {
    return 1.0;
  }
}

function followScroll()
{
  if(allowFollowScroll)
  {
    if(!followScrollLock)
    {
      camPositionLock = player.x - Game.Camera.X;
      if(wayForward == eDirectionLeft && mouse.x < 40)
      {
        Game.Camera.StopTweenPosition();
        
        player.Walk(0, player.y, eNoBlock, eWalkableAreas); //this not working for some reason
        allowWalk = false;
        followScrollLock = true;
      } else if (wayForward == eDirectionRight && mouse.x > 320)
      {
        
        
        Game.Camera.StopTweenPosition();
        player.Walk(Room.Width, player.y, eNoBlock, eWalkableAreas); //this not working for some reason      
        allowWalk = false;
        followScrollLock = true;
      } else {    
        
        Game.Camera.StopTweenPosition(ePauseTween);
        Game.Camera.TweenX(1.0, mouse.x + Game.Camera.X - 180, eEaseOutSineTween, eNoBlockTween);
        allowFollowScroll = false;
        SetTimerWithSeconds(18, 1.5);
      }
    }
    
    
  }  
}

int playerXPos;
int scRightCounter = 0;
int saveCamPos = -1;
int posTicker = 0;
int scRight()
{
  if(saveCamPos == -1)
  {
    saveCamPos = Game.Camera.X;
  }
  if(posTicker == 2)
  {
    scRightCounter++;
    posTicker = 0;
  } else {
    posTicker++;
  }
  
  return saveCamPos+scRightCounter;
  /*
  if(player.x != playerXPos)
  {
    playerXPos = player.x;
    return player.x;
  } else {  
    if(scRightCounter == player.WalkSpeedX)
    {
      scRightCounter = 0;
    } else {
      scRightCounter++;
    }
    return player.x + scRightCounter;    
   
  }*/
  
}

function dollyMove()
{
  if(followScrollLock)
  {
    Game.Camera.X = player.x - camPositionLock;        
  //  Game.Camera.X = scRight();
  }  
}
//seems like a nicer option. need to use the player's screen position to figure out
//how to prevent them falling off the screen.


//works really well,
//maybe include a thing where if you're close to the edge it centres on the player
//if you're far away from the edge it scroller further.

//or we change the process if clicking while the camera is already in motion?
function newCityScroll()
{ 
  allowWalk = true;
  if(allowScroll)
  {
    int camPos = Game.Camera.X;
    int roomMouse = mouse.x + camPos; //the 'room coords' for the mouse    
    int scrollTo;    
    int leftBoundary = camPos + 40;
    int rightBoundary = camPos + 320;
    int rightSide = camPos + 360;
    int leftSide = camPos;
    int difference;
    float timing;
    
    if(roomMouse < leftBoundary || roomMouse > rightBoundary) //checks if the mouse is on the left or right to trigger the rest
    {
      if(roomMouse > player.x) //scrolling right
      {
        wayForward = eDirectionRight;
        if(player.x < rightSide - 80)
        {
          scrollTo =  roomMouse - 80;        
                       
        } else {
          scrollTo =  player.x - 140;
        }
          difference = roomMouse - player.x;   
      } else {                //scrolling left
        wayForward = eDirectionLeft;
        if(player.x > leftSide + 80)
        {
          scrollTo = roomMouse - 280;        
        } else {
          scrollTo =  player.x - 220;
        }
        difference = player.x - roomMouse;
      }      
 
      timing = calculateScrollSpeed(difference);      
      Game.Camera.TweenX(timing, scrollTo, eEaseInOutSineTween, eNoBlockTween); 
      
      allowScroll = false;
      if(timing > 6.0)
      {
        timing = 6.0;
      }
      SetTimerWithSeconds(19, timing);
      
    } else {
     
     // Game.Camera.StopTweenPosition(ePauseTween);
    
    }
  } else {
    followScroll();
  }
}

function centrePlayer()
{
  if(player.x < Game.Camera.X +10 || player.x > Game.Camera.X + 350)
  {
    Game.Camera.TweenX(1.3, player.x - 180, eEaseInOutBounceTween, eBlockTween);
  }
}

function switchScrollBackOn()
{
  if(!allowScroll)
  {
    if(IsTimerExpired(19))
    {
      allowScroll = true;
      centrePlayer();
    } 
  }
  if(!allowFollowScroll)
  {
    if(IsTimerExpired(18))
    {
      allowFollowScroll = true;
    }
  }
}
//cityscroll now runs in laterepetedlyexecute in the global script to reduce 'stuttering' effect
function room_RepExec()
{
  switchScrollBackOn();  
}

function late_repeatedly_execute_always()
{
  dollyMove();
}

function room_Load()
{
   changePlayerLocaleOnRoomEnter();

Game.Camera.SetAt(251,  210);
Game.Camera.SetSize(360, 200);
player.place(409, 385);
//player.SetWalkSpeed(6, 6);

}

function room_Leave()
{

}

function stopDolly()
{
  if(followScrollLock)
  { 
    if(wayForward == eDirectionLeft)
    {
      Game.Camera.TweenX(1.0, Game.Camera.X - 10, eEaseOutSineTween, eNoBlockTween);
    } else {
      Game.Camera.TweenX(1.0, Game.Camera.X + 10, eEaseOutSineTween, eNoBlockTween);
    }    
    followScrollLock = false;
  }
}

function on_mouse_click (MouseButton button)
{
  
  if(button == eMouseLeft)
  {
    if(mouse.Mode == eModeWalkto)
    {
      stopDolly();
      newCityScroll();
      
    }
  }
}

