 // room script file
bool allowScroll = true;

float calculateScrollSpeed(int diff)
{
  if (diff > 340)
  {
    return 11.0;
  }  else if(diff > 300)
  {
    return 10.0;
  } else if (diff > 250)
  {
    return 6.0;
  } else if (diff > 200)
  {
    return 5.0;
  } else if (diff > 150)
  {
    return 4.0;
  } else if (diff > 100)
  {
    return 3.0;
  } else if (diff > 50)
  {
    return 2.0;
  }  else {
    return 1.0;
  }
}


//seems like a nicer option. need to use the player's screen position to figure out
//how to prevent them falling off the screen.


//works really well,
//maybe include a thing where if you're close to the edge it centres on the player
//if you're far away from the edge it scroller further.

//or we change the process if clicking while the camera is already in motion?
function newCityScroll()
{ 
  if(allowScroll)
  {
    int camPos = Game.Camera.X;
    int roomMouse = mouse.x + camPos; //the 'room coords' for the mouse    
    int scrollTo;    
    int leftBoundary = camPos + 40;
    int rightBoundary = camPos + 320;
    int rightSide = camPos + 360;
    int leftSide = camPos;
    int difference;
    float timing;
    
    if(roomMouse < leftBoundary || roomMouse > rightBoundary) //checks if the mouse is on the left or right to trigger the rest
    {
      if(roomMouse > player.x) //scrolling right
      {
        if(player.x < rightSide - 80)
        {
          scrollTo =  roomMouse - 80;        
                       
        } else {
          scrollTo =  player.x - 140;
        }
          difference = roomMouse - player.x;   
      } else {                //scrolling left
        if(player.x > leftSide + 80)
        {
          scrollTo = roomMouse - 280;        
        } else {
          scrollTo =  player.x - 220;
        }
        difference = player.x - roomMouse;
      }      
 
      timing = calculateScrollSpeed(difference);      
      Game.Camera.TweenX(timing, scrollTo, eEaseInOutSineTween, eNoBlockTween); 
      
      allowScroll = false;
      if(timing > 6.0)
      {
        timing = 6.0;
      }
      SetTimerWithSeconds(19, timing);
      
    } else {
     // Game.Camera.StopTweenPosition(ePauseTween);
    }    
  }
}

function centrePlayer()
{
  if(player.x < Game.Camera.X +10 || player.x > Game.Camera.X + 350)
  {
    Game.Camera.TweenX(1.3, player.x - 180, eEaseInOutBounceTween, eBlockTween);
  }
}

function switchScrollBackOn()
{
  if(!allowScroll)
  {
    if(IsTimerExpired(19))
    {
      allowScroll = true;
      centrePlayer();
    } 
  }
}
//cityscroll now runs in laterepetedlyexecute in the global script to reduce 'stuttering' effect
function room_RepExec()
{
  switchScrollBackOn();  
}



function room_Load()
{
   changePlayerLocaleOnRoomEnter();

Game.Camera.SetAt(1104,  1066);

player.x= 1251;
player.y= 1265;
}

function room_Leave()
{

}

function on_mouse_click (MouseButton button)
{
  if(button == eMouseLeft)
  {
    if(mouse.Mode == eModeWalkto)
    {
      newCityScroll();
      
    }
  }
}

