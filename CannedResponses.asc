// new module script
bool paulTalking = false;
bool abiTalking = false;
int testGenders(gender theGender)
{
  return theGender;
}


static void Canned::bothSayAt(const string abiSay, const string paulSay, CharacterDirection direction, int waitLoops)
{          
  cPaul.FaceDirection(direction, eNoBlock); 
  cAbi.FaceDirection(direction, eNoBlock);
    Wait(30);    
  cPaul.LockView(cPaul.SpeechView);
  cAbi.LockView(cAbi.SpeechView);
  cPaul.Animate(cPaul.Loop, 5, eRepeat, eNoBlock, eForwards, 1);
  cAbi.Animate(cAbi.Loop, 5, eRepeat, eNoBlock, eForwards, 1);
  cAbi.SayBackground(abiSay);
  cPaul.SayBackground(paulSay);
    WaitMouseKey(waitLoops);
  cPaul.UnlockView(eStopMoving);
  cAbi.UnlockView(eStopMoving);
  
}

static void Canned::bothSayToEachOther(const string abiSay, const string paulSay, int loops)
{     //have an alt function for saying at each other?
      //default to face the screen    
  if(cPaul.Room == cAbi.Room)
  {
    cPaul.FaceCharacter(cAbi, eNoBlock);
    cAbi.FaceCharacter(cPaul, eNoBlock);    
      Wait(30);
    cPaul.LockView(cPaul.SpeechView);
    cAbi.LockView(cAbi.SpeechView);
    cPaul.Animate(cPaul.Loop, 5, eRepeat, eNoBlock, eForwards, 1);
    cAbi.Animate(cAbi.Loop, 5, eRepeat, eNoBlock, eForwards, 0);
    Overlay* abiSpeechBubble = cAbi.SayBackground(abiSay);
    Overlay* paulSpeechBubble = cPaul.SayBackground(paulSay);
      WaitMouseKey(loops); 
      if(abiSpeechBubble.Valid)
      {
        abiSpeechBubble.Remove();
      }
      if(paulSpeechBubble.Valid)
      {
        paulSpeechBubble.Remove();
      }
    cPaul.UnlockView(eStopMoving);
    cAbi.UnlockView(eStopMoving);
  }    
}


function lookAbiPaul(const string abiSay, const string paulSay)
{
  if(IsPlayerAbi)
  {
    player.Say(abiSay);
  } else {
    player.Say(paulSay);
  }
}

static void Canned::backGroundSayBoth(const string abiSay, const string paulSay, float timing)
{           
  if(IsPlayerAbi)
  {
    cAbi.LockView(cAbi.SpeechView);
    cAbi.Animate(cAbi.Loop, 5, eRepeat, eNoBlock, eForwards, 0);
    player.SayBackground(abiSay);
    abiTalking = true;
    
  } else {
    cPaul.LockView(cPaul.SpeechView);    
    cPaul.Animate(cPaul.Loop, 5, eRepeat, eNoBlock, eForwards, 1);
    player.SayBackground(paulSay); 
    paulTalking = true;
  }  
  SetTimerWithSeconds(2, timing);
}

function stopTalkingChars()
{
  if(abiTalking)
  {
    if( IsTimerExpired(2) )
    {
      abiTalking = false;
      cAbi.UnlockView(eStopMoving);
    }
  }
  if(paulTalking)
  {
    if(IsTimerExpired(2))
    {
     paulTalking = false; 
     cAbi.UnlockView(eStopMoving);
    }
  }
}
function otherPlayerSay(const string abiSay, const string paulSay)
{
  if(IsPlayerAbi)
  {
    cPaul.Say(paulSay);
  } else {
    cAbi.Say(abiSay);
  }
}

function displayInvLook(const string abiSay, const string paulSay)
{
    if(IsPlayerAbi){
      DisplayAtY(150, abiSay);
    } else {
      DisplayAtY(150, paulSay);
    }
}

static void Canned::tooFar(){
  if(IsPlayerAbi){
    player.Say("I'm not close enough!");
  } else {
    player.Say("Cant...Reach...");
    
  }
}

static void Canned::cantTake(int howMany){
  if( howMany == 1 )
  {
    if(IsPlayerAbi)
    {
      switch(Random(1))
      {
        case 0:
          player.Say("As much as I want to pick that up and carry it around with me,");
          player.Say("I just don't have the pockets for it.");
        break;        
        case 1:
          player.Say("It's too big!");
          if(cAbi.Room==cPaul.Room){            
            cPaul.Say("That's what she said!");
            cAbi.FaceCharacter(cPaul);
            player.Say("Ugh...");
          }
        break;      
      }
    } else {
      player.Say("I couldn't possibly take that!");
    }
    
  } else if ( howMany == 2 ){
    if(IsPlayerAbi)
    {
      player.Say("I can't take them.");
    } else {
      player.Say("Take those?");
      cPaul.angry();
      player.Say("That's preposterous.");
      cPaul.cool();
    } 
  } else {
    lookAbiPaul("That's not the kind of thing anyone could take.", 
                "That's more like a concept then a physical thing one can pick up and carry around with them.");
  }
}

static void Canned::cantTakePerson(bool himNotHer)
{
  if(himNotHer)
  {
    lookAbiPaul("He's too heavy.", "I don't think he wants a piggy-back ride.");
  } else {
    lookAbiPaul("She's too heavy.", "I don't think she wants a piggy-back ride.");
  }
}

static void Canned::fuckAnyone(int itZeroSheOneHeTwo,  bool fancyThem)
//function fuckAnyone(gender itZeroSheOneHeTwo,  bool fancyThem)
{
  if(fancyThem)
  {
    switch(itZeroSheOneHeTwo)
    {
      case 1:
        lookAbiPaul("She's got it going on!", 
                    "She seems nice. I wonder if she's single?");
      break;
      case 2:
        lookAbiPaul("He's kind of alright.", 
                    "He's pretty cute, but I should probably get to know him first!");
      break;    
      default:
        lookAbiPaul("I'd tap that.", 
                    "Hmmm, if the time was right, maybe I would.");
      break;
    }
  } else {
    switch(itZeroSheOneHeTwo)
    {    
      case 1:
        lookAbiPaul("She's cute, but not really my type.",
                    "Ah...I'm just not that into her.");
      break;
      case 2:
        lookAbiPaul("Ew. No.",
                    "Maybe after a few beers?");
      break;    
      default:
        lookAbiPaul("Um... Not my kind of thing.",
                    "It doesn't inspire me.");
      break;
    }
  }
}



static void Canned::notThere()
{  
  lookAbiPaul("Ew, not there!", "That's not the best place for it.");
}

static void Canned::moveDontUse()
{
  player.Say("To me a door is the kind of thing you 'open' or 'close', that being a kind of movement.");
  player.Say("Perhaps if I were to 'move' the door instead?");
}

static void Canned::noMoving()
{
  if(IsPlayerAbi)
  {
    player.Say("It won't budge.");
  } else {
    player.Say("That is pretty unmovable.");
  }
}

static void Canned::noUsing()
{
  if(IsPlayerAbi)
  {
    player.Say("I don't know what to use it for.");
  } else {
    player.Say("Not sure that it's something I can turn on or use or whatever.");
  }
}

static void Canned::wontWork()
{
  if(IsPlayerAbi)
  {
    player.Say("I can't say that's gonna work.");
  } else {
    player.Say("Hmmm...");
    player.Say("I reckon that'll won't work at all.");
  }
}

static void Canned::noTalking()
{
  lookAbiPaul("I've got plenty of real people to talk to!",
              "I don't see the point in talking to an inanimate thing.");
}


function greetEachOther()
{
  //character enters room where other character is, will say hi.
  //will only do this once in each locale
  //ie abi returns to the flat, first time encountering paul there will say hi.
  //will have a different response in each locale, like they're more surprised to see each other.
  /*
    each locale needs a 'greeted' variable which will be zero, but increments by 1 when a char enters the locale
    it decrements when a char leaves.
    *this will conflict with the follow algorythm
    if the variable is 2 they say hello, it increments again to 3
    
  
  */
  
}

function repeatedly_execute()
{ 
  stopTalkingChars();
}


static int Canned::GetYear()
{
  DateTime *dt = DateTime.Now;
  return dt.Year;
}

static int Canned::GetGameYear()
{
  return Canned.GetYear() - 18;
}

static int Canned::getRealTime()
{
  DateTime *dt = DateTime.Now;
  return dt.RawTime;
}