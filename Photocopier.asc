// new module script

int pileIndex;
int photocopyState = 0;
int paperLoaded = 0;
int copyMode = eCopyMode_copy;
int delayClicker = 0;
bool paperSupplyOpen = false;
bool machineOpen = false;
InventoryItem* loadedItem;

static String Photocopier::getDescription(InventoryItem* thePrint)
{
  return thePrint.GetTextProperty("printLook");
}

static void Photocopier::stopGreenLight()
{
  bCopyGood.NormalGraphic = 2301;
}

static bool Photocopier::delay(float seconds)
{
  delayClicker++;
  
  if(delayClicker > FloatToInt(seconds * 40.0)) //times 40 to make it a rough seconds delay thing, also make float
  {
    delayClicker = 0;    
    return true;
  } else {
    return false;
  }
}

static int Photocopier::SCABS(int num)
{    
  if(num == -1) //if default, just return current scabs
    { return photocopyState; 
  } else if (num == 1)  //if 1, increment
  { 
    photocopyState++;
  } else {
    photocopyState = num; //if another number, set to this number.
  }
  return photocopyState;
}




static int Photocopier::mode()
{
  return copyMode;
}

function setModeGrapic()
{
  switch(copyMode)
  {
    case eCopyMode_copy:
      bModeIcon.NormalGraphic = 2294;
      
    break;
    case eCopyMode_enlarge:
      bModeIcon.NormalGraphic = 2295;
    break;
    case eCopyMode_reduce:
      bModeIcon.NormalGraphic = 2296;
    break;
  }
}

static void Photocopier::changeMode()
{
  aPhone3.Play(eAudioPriorityHigh);
  if(copyMode < 2)
  {
    copyMode++;
  } else {
    copyMode = 0;
  }
  setModeGrapic();
}

static int Photocopier::addPaperReem()
{
  player.LoseInventory(iPaperReem);
  paperLoaded = 100;
}

static int Photocopier::paperSupply()
{
  return paperLoaded;
}

static void Photocopier::loadItem(InventoryItem* theItem)
{
  loadedItem = theItem;
  player.LoseInventory(theItem);

}

static void Photocopier::removeItem()
{
  if(loadedItem.ID > 0)
  {
    displayAlert(eAlertInvPickup, false, loadedItem);
    player.AddInventory(loadedItem);
    loadedItem = null;    
  } else {
    Display("error: photocopier has no inv item loaded");
  }  
}

static int Photocopier::whatsLoaded()
{ 
  if(loadedItem)
  {
    return loadedItem.ID;
  } else {
    return 0;
  }
}

static String Photocopier::nameWhatsLoaded()
{
  return loadedItem.Name;
}

static void Photocopier::showPanel()
{  
  Time.FreezeTime();
  gIconbar.Visible = false;  
  gPhotocopier.Y = -100;
 // gPhotocopier.Transparency = 100;
  gPhotocopier.Transparency = 0;
  gPhotocopier.Visible = true;
  gPhotocopier.TweenPosition(1.0, 0, 0, eEaseInOutSineTween, eNoBlockTween);
 // gPhotocopier.TweenTransparency(0.1, 0, eEaseInOutSineTween, eBlockTween, 0.8);
}

static void Photocopier::hidePanel()
{
  bCopyGood.NormalGraphic = 2301;
  gPhotocopier.TweenPosition(0.4, 0, -100, eEaseInOutSineTween, eNoBlockTween);
  gPhotocopier.TweenTransparency(0.2, 100, eEaseInOutSineTween, eBlock);
  gPhotocopier.Visible = false;
  Time.FreezeTime(true); 
  gIconbar.Visible = true;
}


static void Photocopier::toggleOpenPaperSupply()
{
  if(paperSupplyOpen)
  {
    paperSupplyOpen = false;
  } else {
    paperSupplyOpen = true;
  }
}

static bool Photocopier::IsPaperSupplyOpen()
{
  return paperSupplyOpen;
}

static bool Photocopier::IsMachineOpen()
{
  return machineOpen;
}

static void Photocopier::toggleOpenMachine()
{
  if(machineOpen)
  {
    machineOpen = false;
  } else {
    machineOpen = true;
  }
}

static int Photocopier::Mode(enumCopyMode num)
{
  if(num == -1)
  {
    return copyMode;
  } else {
    copyMode = num;
    return copyMode;
  }
}

static int Photocopier::GetPaperLoaded(int num)
{
  if(num == -1)
  {
    return paperLoaded;  
  } else {
    paperLoaded = num;
    return paperLoaded;
  }
}

function copyThing()
{
  //animate paper coming out
  if(loadedItem != null && !Photocopier.IsMachineOpen())
  {
    switch(loadedItem)
    {
      case iKeyCard:
        switch(copyMode)
        {
          case eCopyMode_copy:            
            cBob.AddInventory(iPaper_keyCard_copy);
          break;
          case eCopyMode_enlarge:            
            cBob.AddInventory(iPaper_keyCard_Big);
          break;
          case eCopyMode_reduce:             
            cBob.AddInventory(iPaper_keyCard_small);
          break;
        }
      break;
      case iPaulsCard:
        switch(copyMode)
        {
          case eCopyMode_copy:
            cBob.AddInventory(iPaper_eftposCard_copy);
          break;
          case eCopyMode_enlarge:
            cBob.AddInventory(iPaper_eftposCard_big);
          break;
          case eCopyMode_reduce: 
            cBob.AddInventory(iPaper_eftposCard_small);
          break;
        }
      break;
      case iAbiCard:
         switch(copyMode)
        {
          case eCopyMode_copy:
            cBob.AddInventory(iPaper_eftposCard_copy);
          break;
          case eCopyMode_enlarge:
            cBob.AddInventory(iPaper_eftposCard_big);
          break;
          case eCopyMode_reduce: 
            cBob.AddInventory(iPaper_eftposCard_small);
          break;
        }
      break;
    }    
  } else {
    cBob.AddInventory(iPaper_blank);
  }
}

static void Photocopier::copyButton()
{
  aPhone1.Play(eAudioPriorityHigh);
  if(paperLoaded && !paperSupplyOpen)
  {
    bCopyGood.Animate(122, 0, 0, eRepeat);
    copyThing();
    Photocopier.SCABS(10);
  } else {
    bCopyError.Animate(121, 0, 0, eOnce);
  }
}


static int Photocopier::countPrintsInTray()
{
  int invCount;
    
  if(iwCopier.ItemCount == 0)
  {
    return 0;
  } else {
    for (int i = 0; i < iwCopier.ItemCount; i++)
    {
      invCount += cBob.InventoryQuantity[iwCopier.ItemAtIndex[i].ID];  
    }
  }    
  return invCount;
}

//counts print in the special print inventory
int countItemsInInv(InvWindow* theWindow, Character* theChar)
{
 int invCount;
    
  if(theWindow.ItemCount == 0)
  {
    return 0;
  } else {
    for (int i = 0; i < theWindow.ItemCount; i++)
    {
      invCount += theChar.InventoryQuantity[theWindow.ItemAtIndex[i].ID];  
    }
  }    
  return invCount; 
}


function emptyCopier()
{
  int countedBefore = Photocopier.countPrintsInTray();
  
  for(int i = 0; i < countedBefore; i++)
  {    
    cBob.LoseInventory(iwCopier.ItemAtIndex[0]);
  } 
}

int copyIndexAbi = -1;
int copyIndexPaul = -1;

static void Photocopier::resetCopyIndex(Character* theChar)
{
  if(theChar == cAbi)
  {
    copyIndexAbi = -1;
  } else {
    copyIndexPaul = -1;
  }
}
int getInvIndex(InventoryItem* theItem)
{
  for (int i = 0; i < invCustom.ItemCount; i++)
  {
    if(invCustom.ItemAtIndex[i] == theItem)
    {      
      return i;      
    }
  }
   return 0;
}


function isItAPrint(InventoryItem* theItem)
{
  if(theItem == iPaper_blank ||
    theItem == iPaper_eftposCard_big ||
    theItem == iPaper_eftposCard_copy ||
    theItem == iPaper_eftposCard_small ||
    theItem == iPaper_keyCard_Big ||
    theItem == iPaper_keyCard_copy ||
    theItem == iPaper_keyCard_small ||
    theItem == iPileOfCopies
    )
  {
    return true;
  } else {
    return false;
  }
}

//returns index of first instance of print or paper pile  in player inv
int findFirstPrintInPlayerInv()
{
  for(int i = 0; i < invCustom.ItemCount; i++)
  {
    if(isItAPrint(invCustom.ItemAtIndex[i]))
    {
     return i; 
    }
  }  
  return invCustom.ItemCount;
}

function setCopyIndex()
{
  copyIndexAbi = findFirstPrintInPlayerInv();
  copyIndexPaul = findFirstPrintInPlayerInv();  
}



static void Photocopier::pickUpCopies()
{
  InventoryItem* anItem;
  if(IsPlayerAbi)
  {
    //copies all items to alt inv
    for (int i = 0; i < iwCopier.ItemCount; i++)
    {
      for(int p = 0; p < cBob.InventoryQuantity[iwCopier.ItemAtIndex[i].ID]; p++)
      {
        cSally.AddInventory(iwCopier.ItemAtIndex[i]);       
      }             
    }
    
    //copies all alt inv items to player inv at index of first paper
    for (int i = 0; i < iwAbiCopies.ItemCount; i++)
    {
      cAbi.AddInventory(iwAbiCopies.ItemAtIndex[i], findFirstPrintInPlayerInv());
    }          
  } else {
    //copy for paul
    /*
    for (int i = 0; i < iwPaulsCopies.ItemCount; i++)
    {
      cPaul.AddInventory(iwPaulsCopies.ItemAtIndex[i], pileIndex);
    }*/
  }
 
  emptyCopier();
}

function Print(const string whatToPrint)
{
  DisplayAtY(150, whatToPrint);
}


static void Photocopier::lookCopy(InventoryItem* theItem)
{
  if(IsPlayerAbi)
  {    
    Print(String.Format("It's %s.", Photocopier.getDescription(theItem)));
    if(cSally.InventoryQuantity[theItem.ID] > 1)
    {
      Print(String.Format("I've got %s of these.", 
            HandyHelper.stringifyInt(cSally.InventoryQuantity[theItem.ID])));
    }
    switch(Random(2))
    {
      case 0:
        Print("Seems pretty useless...");
      break;
      case 1:
        Print("It might be good for insurance purposes?");
      break;
      case 2:
        Print("I'm not sure if this was worth the trouble.");
      break;
     
    }
    
  } else {
    Print(String.Format("It's %s.", Photocopier.getDescription(theItem)));
     
    if(cFred.InventoryQuantity[theItem.ID] > 1)
    {
      Print(String.Format("I've got %s of these.", 
            HandyHelper.stringifyInt(cFred.InventoryQuantity[theItem.ID])));
    }
    Print("Pretty cool!");
  }
}




bool pileLooking = false;
static void Photocopier::lookPile() //looking at pile
{
  pileIndex = getInvIndex(iPileOfCopies);
  player.LoseInventory(iPileOfCopies);
  pileLooking = true;
  if(IsPlayerAbi)
  {
    for (int i = 0; i < iwAbiCopies.ItemCount; i++)
    {
      cAbi.AddInventory(iwAbiCopies.ItemAtIndex[i], pileIndex);
    }
  } else {
    for (int i = 0; i < iwPaulsCopies.ItemCount; i++)
    {
      cPaul.AddInventory(iwPaulsCopies.ItemAtIndex[i], pileIndex);
    }
  }
}
//make this actually count propery, there's a helper for that
function setPaperPilePic(InvWindow* theChar)
{
  if(theChar.ItemCount == 2)
  {
    iPileOfCopies.Graphic = 2340;
  } else {
    iPileOfCopies.Graphic = 2341;
  }
}

function setpilePicPlayer()
{
  if(IsPlayerAbi)
  {
    setPaperPilePic(iwAbiCopies);
  } else {
    setPaperPilePic(iwPaulsCopies);
  }
}

int countPrintsPlayer()
{
  int result;
  if(IsPlayerAbi)
  {
    result = countItemsInInv(iwAbiCopies, cSally);
  } else {
    result = countItemsInInv(iwPaulsCopies, cFred);
  }
  return result;
}

function takeAwayOne(InventoryItem* theItem)
{
  while(player.HasInventory(theItem))
  {
    player.LoseInventory(theItem);
  }
}
//checks if the player has prints they shouldn't in case they're not in the alt inv
function takeAwayPlayerPrints()
{
  takeAwayOne(iPaper_blank);
  takeAwayOne(iPaper_eftposCard_big);
  takeAwayOne(iPaper_eftposCard_copy);
  takeAwayOne(iPaper_eftposCard_small);
  takeAwayOne(iPaper_keyCard_Big);
  takeAwayOne(iPaper_keyCard_copy);
  takeAwayOne(iPaper_keyCard_small);  
}


//cuont inc items in special inv if one item change to jst the item, not the pile
static void Photocopier::restorePile() //should go on OPEN inventory
{
  if( player.HasInventory(iPaper_blank)           ||
  player.HasInventory(iPaper_eftposCard_big)  ||
  player.HasInventory(iPaper_eftposCard_copy) ||
  player.HasInventory(iPaper_eftposCard_small)||
  player.HasInventory(iPaper_keyCard_Big)     ||
  player.HasInventory(iPaper_keyCard_copy)    ||
  player.HasInventory(iPaper_keyCard_small)   ||
  player.HasInventory(iPileOfCopies)
  )
  {
    if(countPrintsPlayer() == 0)
    { 
      //if accidently the player has stuff they shouldn't (it's not in the alt inv for prints)
      //take them away!
      if(player.HasInventory(iPileOfCopies))
      {
        player.LoseInventory(iPileOfCopies);        
      }
      takeAwayPlayerPrints();
    } else if (countPrintsPlayer() == 1)
    {
      //if has only one thing remove pile and replace with the one item
      setCopyIndex();
      
      if(player.HasInventory(iPileOfCopies))
      {
        player.LoseInventory(iPileOfCopies);
      }
      if(IsPlayerAbi)
      {
        if(!player.HasInventory(iwAbiCopies.ItemAtIndex[0]))
        {
          player.AddInventory(iwAbiCopies.ItemAtIndex[0], copyIndexAbi);
        }
      } else {
        //copy for paul
      }
      
      
    } else if (countPrintsPlayer() > 1)
    {      
      setCopyIndex();
      takeAwayPlayerPrints();
      if(!player.HasInventory(iPileOfCopies))
      {
        player.AddInventory(iPileOfCopies, copyIndexAbi);
        //copy for paul
      }
      setpilePicPlayer();
    }
  }    
}

static void Photocopier::losePrint(InventoryItem* theItem)
{
  if(IsPlayerAbi)
  {
    cAbi.LoseInventory(theItem);
    cSally.LoseInventory(theItem);
  } else {
    cPaul.LoseInventory(theItem);
    cPaul.LoseInventory(theItem);
  }
}

int countCharsPrints(Character* theChar, InvWindow* theWindow)
{
  int invCount;
    
  if(theWindow.ItemCount == 0)
  {
    return 0;
  } else {
    for (int i = 0; i < theWindow.ItemCount; i++)
    {
      invCount += theChar.InventoryQuantity[theWindow.ItemAtIndex[i].ID];  
    }
  }    
  return invCount;
}

function losePrint(InventoryItem* theItem)
{
  while(player.HasInventory(theItem))
  {
    player.LoseInventory(theItem);
  }
  if(IsPlayerAbi)
  {
    while(cSally.HasInventory(theItem))
    {
      cSally.LoseInventory(theItem);
    }
  } else {
    while(cFred.HasInventory(theItem))
    {
      cFred.LoseInventory(theItem);
    }
  }
  
}

static void Photocopier::loseAllPrints()
{
  if(IsPlayerAbi)
  {
    while(iwAbiCopies.ItemCount)
    {
      losePrint(iwAbiCopies.ItemAtIndex[0]);
    }
  } else {
    while(iwPaulsCopies.ItemCount)
    {
      losePrint(iwPaulsCopies.ItemAtIndex[0]);
    }
  }
  if(player.HasInventory(iPileOfCopies))
  {
    player.LoseInventory(iPileOfCopies);
  }  
}

static void Photocopier::Recycle(InventoryItem* theItem)
{
  player.LoseInventory(theItem);
  if(IsPlayerAbi)
  {    
    cSally.LoseInventory(theItem);
  } else {
    cFred.LoseInventory(theItem);
  }
}