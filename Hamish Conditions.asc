//COnditions for Hamish Puzzles

bool inToilet = false;
int inCubicle = 0;
bool drankCoffee = false;
bool ateCake = false;
bool toiletRollInCubicle = true;
bool tpInCubicle[4];
int charInCubicle[4];
bool hesTrappedInToilet = false;
bool finishedInToilet = false;
bool keyCard = false;
int whenWillGiveKeyCardForTP = 0;
bool didGivePlayerKeyCard = false;

static bool Hamish_Conditions::gavePlayerKeycard()
{
  return didGivePlayerKeyCard;
}

static void Hamish_Conditions::setGivePlayerKeycard(bool cond)
{
  didGivePlayerKeyCard = cond;
}

static int Hamish_Conditions::isFinishedInToilet()
{
  return finishedInToilet;
}

static void Hamish_Conditions::setFinishedInToilet(bool setIt)
{
  finishedInToilet = setIt;
}
static int Hamish_Conditions::willGiveKeyCardForTP()
{
  return whenWillGiveKeyCardForTP;
}

static void Hamish_Conditions::SetWillGiveKeyCardForTP(int input)
{
  whenWillGiveKeyCardForTP = input;
}

static bool Hamish_Conditions::isInToilet()
{
  if(cHamish.Room == 17)
  { 
    inToilet = true; 
  } else { 
    inToilet = false; 
  }
  return inToilet;
}

static int Hamish_Conditions::whichCubicleIsHeIn()
{
  return inCubicle;
}

static bool Hamish_Conditions::hasHadCoffee()
{
  return drankCoffee;
}

static bool Hamish_Conditions::hasEatenCake()
{
  return ateCake;
}

static bool Hamish_Conditions::isAToiletRollInCubicle()
{
  return toiletRollInCubicle;
}

static bool Hamish_Conditions::isTrappedInToilet()
{
  return hesTrappedInToilet;
}

static bool Hamish_Conditions::hasKeyCard()
{
  return keyCard;
}

static void Hamish_Conditions::putInToilet(bool input)
{
  inToilet = input;
}

static void Hamish_Conditions::putInCubicle(int input)
{
  inCubicle = input;
}

static void Hamish_Conditions::giveCoffee(bool giveNotTake)
{
  drankCoffee = giveNotTake;
}

static void Hamish_Conditions::giveCake(bool giveNotTake)
{
  ateCake = giveNotTake;
}

static void Hamish_Conditions::setToiletRollAvailability(bool exist)
{
  toiletRollInCubicle = exist;
}

static void Hamish_Conditions::trap(bool doOrDont)
{
  hesTrappedInToilet = doOrDont;
}

static void Hamish_Conditions::getKeyCard(bool getIt)
{
  keyCard = getIt;
}

int delayClicker = 0;
static bool Hamish_Conditions::delay(float seconds)
{
  delayClicker++;  
  
  if(delayClicker > FloatToInt(seconds * 40.0)) //times 40 to make it a rough seconds delay thing, also make float
  {
    delayClicker = 0;    
    return true;
  } else {
    return false;
  }
}

int theSCABS = 0;

function SCABS(int num)
{  
  if(num == -1) //if default, just return current scabs
    { return theSCABS; 
  } else if (num == 1)  //if 1, increment
  { 
    theSCABS++;
  } else {
    theSCABS = num; //if another number, set to this number.
  }
  return theSCABS;
}

function hamishToiletProblem()
{
 
  if(!Hamish_Conditions.isTrappedInToilet())
  {
    if(!Hamish_Conditions.isAToiletRollInCubicle() && Hamish_Conditions.isInToilet())
    {
      Display("trapping hamish");
      Hamish_Conditions.trap(true);
    }
  }
}

function initTpArray()
{
  tpInCubicle[1] = true;
  tpInCubicle[2] = true;
  tpInCubicle[3] = true;
}

static bool Hamish_Conditions::isThereTpInCub(int id)
{
  return tpInCubicle[id - 2];
}

static void Hamish_Conditions::putTpInCub(int id, bool put)
{
  tpInCubicle[id - 2] = put;
}

static void Hamish_Conditions::putCharInCub(Character* theChar, int theCub)
{
  charInCubicle[theCub] = theChar.ID;
}

static void Hamish_Conditions::vacateCub(int theCub)
{
  charInCubicle[theCub] = 0;  
}

static int Hamish_Conditions::whosInCub(int theCub)
{
  return charInCubicle[theCub];
}

static int Hamish_Conditions::chooseCubicle()
{
  return 1;
}

bool considerCubicle(int theCub)
{
  if(charInCubicle[theCub] == 0 && tpInCubicle[theCub] == true)
  {
    return true;
  } else {
    return false;
  }
}

bool secondConsiderationOfCubicle(int theCub)
{
  if(charInCubicle[theCub] == 0)
  {
    return true;
  } else {
    return false;
  }
}

int hamishChoosingCubicle()
{
  if(considerCubicle(3))
  {
    return 3;
  }
  if(considerCubicle(1))
  {
    return 1;
  }
  if(considerCubicle(2))
  {
    return 2;
  }
  
  if(secondConsiderationOfCubicle(3))
  {
    return 3;
  }
  
  if(secondConsiderationOfCubicle(1))
  {
    return 1;
  }
  
  if(secondConsiderationOfCubicle(2))
  {
    return 2;
  }
  return 0;
}


function initCubArray()
{
  for(int i = 0; i < 4; i++)
  {    
    charInCubicle[i] = 0;
  }
}

function game_start()
{
  initTpArray();
  initCubArray();
}

function repeatedly_execute()
{
  hamishToiletProblem();
}