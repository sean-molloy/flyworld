//COnditions for Hamish Puzzles

bool inToilet = false;
int inCubicle = 0;
bool drankCoffee = false;
bool ateCake = false;
bool toiletRollInCubicle = true;
bool tpInCubicle[4];
int charInCubicle[4];
int toiletXCoords[4];
bool hesTrappedInToilet = false;
bool finishedInToilet = false;
bool keyCard = false;
int whenWillGiveKeyCardForTP = 0;
bool didGivePlayerKeyCard = false;



static void Hamish_Conditions::StandView()
{
  cHamish.ChangeView(105);
  cHamish.SpeechView = 201;
  cHamish.SetProperty("normalSpeechView", 201);
  cHamish.SetProperty("awkwardView", 201);  
  cHamish.SetProperty("angryView",201);
}

static void Hamish_Conditions::SitView()
{
  cHamish.ChangeView(68);
  cHamish.SpeechView = 68;
  cHamish.SetProperty("normalSpeechView", 68);
  cHamish.SetProperty("awkwardView", 68);  
  cHamish.SetProperty("angryView",68);
}


static bool Hamish_Conditions::gavePlayerKeycard()
{
  return didGivePlayerKeyCard;
}

static void Hamish_Conditions::setGivePlayerKeycard(bool cond)
{
  didGivePlayerKeyCard = cond;
}

static int Hamish_Conditions::isFinishedInToilet()
{
  return finishedInToilet;
}

static void Hamish_Conditions::setFinishedInToilet(bool setIt)
{
  finishedInToilet = setIt;
}
static int Hamish_Conditions::willGiveKeyCardForTP()
{
  return whenWillGiveKeyCardForTP;
}

static void Hamish_Conditions::SetWillGiveKeyCardForTP(int input)
{
  whenWillGiveKeyCardForTP = input;
}

static int Hamish_Conditions::whichCubicleIsHeIn()
{
  for(int i = 0; i < 4; i ++)
  {
    if(charInCubicle[i] == cHamish.ID)
    {
      return i;
    }
  }
  return 0;
}

static bool Hamish_Conditions::hasHadCoffee()
{
  return drankCoffee;
}

static bool Hamish_Conditions::hasEatenCake()
{
  return ateCake;
}

static bool Hamish_Conditions::isAToiletRollInCubicle()
{
  return toiletRollInCubicle;
}

static bool Hamish_Conditions::isTrappedInToilet()
{
  return hesTrappedInToilet;
}

static bool Hamish_Conditions::hasKeyCard()
{
  return keyCard;
}


static void Hamish_Conditions::giveCoffee(bool giveNotTake)
{
  drankCoffee = giveNotTake;
}

static void Hamish_Conditions::giveCake(bool giveNotTake)
{
  ateCake = giveNotTake;
}

static void Hamish_Conditions::setToiletRollAvailability(bool exist)
{
  toiletRollInCubicle = exist;
}

static void Hamish_Conditions::trap(bool doOrDont)
{
  hesTrappedInToilet = doOrDont;
}

static void Hamish_Conditions::getKeyCard(bool getIt)
{
  keyCard = getIt;
}

int delayClicker = 0;
static bool Hamish_Conditions::delay(float seconds)
{
  delayClicker++;  
  
  if(delayClicker > FloatToInt(seconds * 40.0)) //times 40 to make it a rough seconds delay thing, also make float
  {
    delayClicker = 0;    
    return true;
  } else {
    return false;
  }
}

int theSCABS = 0;

static int Hamish_Conditions::SCABS(int num)
{  
  if(num == -1) //if default, just return current scabs
    { return theSCABS; 
  } else if (num == 1)  //if 1, increment
  { 
    theSCABS++;
  } else {
    theSCABS = num; //if another number, set to this number.
  }
  return theSCABS;
}

int whichCubIsHamishIn()
{
  for(int i = 0; i < 4; i++)
  {
    if(charInCubicle[i] == cHamish.ID)
    {
      return i;
    }
  }
  return 0;
}


function initTpArray()
{
  tpInCubicle[1] = true;
  tpInCubicle[2] = true;
  tpInCubicle[3] = true;
}

static bool Hamish_Conditions::isThereTpInCub(int id)
{
  return tpInCubicle[id - 2];
}

static void Hamish_Conditions::putTpInCub(int id, bool put)
{
  tpInCubicle[id - 2] = put;
}

static void Hamish_Conditions::putCharInCub(Character* theChar, int theCub)
{
  charInCubicle[theCub] = theChar.ID;
  theChar.SetProperty("toiletCub", theCub);
}

static void Hamish_Conditions::vacateCub(int theCub)
{
  charInCubicle[theCub] = -1;  
  
}

static int Hamish_Conditions::whosInCub(int theCub)
{
  return charInCubicle[theCub];
}

bool considerCubicle(int theCub)
{
  if(charInCubicle[theCub] == -1 && tpInCubicle[theCub] == true)
  {
    return true;
  } else {
    return false;
  }
}

bool secondConsiderationOfCubicle(int theCub)
{
  if(charInCubicle[theCub] == -1)
  {
    return true;
  } else {
    return false;
  }
}

int hamishChoosingCubicle()
{
  if(considerCubicle(3))
  {
    return 3;
  }
  if(considerCubicle(1))
  {
    return 1;
  }
  if(considerCubicle(2))
  {
    return 2;
  }
  
  if(secondConsiderationOfCubicle(3))
  {
    return 3;
  }
  
  if(secondConsiderationOfCubicle(1))
  {
    return 1;
  }
  
  if(secondConsiderationOfCubicle(2))
  {
    return 2;
  }
  return 0;
}


function hamishToiletProblem()
{ 
  if(!Hamish_Conditions.isTrappedInToilet())
  {
    if(cHamish.Room == 17)
    {
      if(!tpInCubicle[whichCubIsHamishIn()])
      {
        Hamish_Conditions.trap(true);
      }
    }
  }
}

static void Hamish_Conditions::putHamishInToilet()
{
  int toilet = hamishChoosingCubicle();
  Hamish_Conditions.putCharInCub(cHamish, toilet);
  cHamish.ChangeRoom(17, toiletXCoords[toilet], toiletXCoords[0], eDirectionDown);
  cHamish.Baseline = 5;
  cHamish.Loop = eDirectionDownLeft;
  hamishToiletProblem();
}

static void Hamish_Conditions::hamishFinishInToilet()
{
  cHamish.Baseline = -1;
  for(int i = 0; i < 4; i++)
  {
    if(charInCubicle[i] == cHamish.ID)
    {
      charInCubicle[i] = -1;
    }
  }
}

function initCubArray()
{
  for(int i = 0; i < 4; i++)
  {    
    charInCubicle[i] = -1;
  }
}

function initToiletCoords()
{
  toiletXCoords[0] = 131;
 // toiletXCoords[0] = 130;
  toiletXCoords[1] = 165;
  toiletXCoords[2] = 201;
  toiletXCoords[3] = 238;
}

function game_start()
{
  initTpArray();
  initCubArray();
  initToiletCoords();
}

bool isProtagInToilet(Character* theChar)
{
  int charID = theChar.ID;
  
  for(int i = 0; i < 4; i++)
  {        
    if(charInCubicle[i] == charID)
    {            
      return true;
    }
  }    
  return false;
}



static void Hamish_Conditions::moveCharsOutOfToilet()
{
  Character* theChar = cAbi;
  bool areTheyInThere;
  
  if(IsPlayerAbi)
  {
    theChar = cPaul;   
  } 
  
  if(theChar.y < 134 && !isProtagInToilet(theChar))
  {      
    theChar.x = 136; 
    theChar.y = 136;
    theChar.Loop = 1;
  }
}

static void Hamish_Conditions::hamishReturnsToiletPaper(Object* theDoor)
{
  Object* tpHolder;
  switch(theDoor)
  {
    case object[eTOBdoor1]:
      tpHolder = object[eTOBtoiletPaper1];
    break;
    case object[eTOBdoor2]:
      tpHolder = object[eTOBtoiletPaper2];
    break;
    case object[eTOBdoor3]:
      tpHolder = object[eTOBtoiletPaper3];
    break;    
  }
   Hamish_Conditions.putTpInCub(tpHolder.ID, true);
   tpHolder.Graphic = 1752;
}

static void Hamish_Conditions::InvToilet()
{
  String toSay;
  if(player.ActiveInventory == iToiletPaper)
      {
        lookAbiPaul("Hey Hamish!","Hey guy,");
        player.Say("Want some toilet paper?");
        if(Hamish_Conditions.isTrappedInToilet())
        {
          cHamish.Say("Yes! Thank you!");
         
          if(Hamish_Conditions.willGiveKeyCardForTP() == 1)     
          {
            player.Say("Here you go.");
            cHamish.Say("Thanks.");
            cHamish.Say("Here's the keycard.");            
            Hamish_Conditions.getKeyCard(false);
            Hamish_Conditions.setGivePlayerKeycard(true);  
            
            cAbi.AddInventory(iKeyCard);
            
          } else if(Hamish_Conditions.willGiveKeyCardForTP() == 2) //abi changed mind
          {
            player.Say("I changed my mind about the keycard thing.");
            cHamish.Say("Oh...");
            cHamish.Say("Yeah, here you go.");
            player.Say("Cool, here's the toilet paper.");
            cHamish.Say("Cheers...");
            
            Hamish_Conditions.getKeyCard(false);
            
            Hamish_Conditions.setGivePlayerKeycard(true);  
            cAbi.AddInventory(iKeyCard);
          }
          player.LoseInventory(iToiletPaper);
          Hamish_Conditions.setToiletRollAvailability(true);
          Hamish_Conditions.putTpInCub(Hamish_Conditions.whichCubicleIsHeIn() + 3, true);
          Hamish_Conditions.trap(false);
          Hamish_Conditions.hamishReturnsToiletPaper(object[Hamish_Conditions.whichCubicleIsHeIn()]);
          player.ActiveInventory = null;
         
        } else {
          cHamish.Say("No, I'm all good in here.");
          lookAbiPaul("Sure you don't want it?","Anything else I can help you with?");
          cHamish.Say("Uh-");
          cHamish.Say("No. I'm good.");
          
        }
      } else {
        toSay = String.Format("Hey, want %s?",player.ActiveInventory.Name);
        player.Say(toSay);
        cHamish.Say("Um.");
        toSay = String.Format("Nah I'm okay without %s just now...",player.ActiveInventory.Name);
        cHamish.Say(toSay);
      }
}

static void Hamish_Conditions::TalkInToilet()
{
  cHamish.Say("Um...");
  WaitMouseKey(25);
  cHamish.Say("It's Hamish.");
  dAbitoHamishToiletIntro.Start();
  if(Hamish_Conditions.isTrappedInToilet())
  {
   if(Hamish_Conditions.hasKeyCard())
   {
     //hamish stuck has keycard
     dAbiToHamishCard.Start();
   } else {
     //hamish stuck, no keycard
     dAbiToHamishNOCARD.Start();             
   }
  } else {
   cHamish.Say("Go away please.");
   lookAbiPaul("Just making conversation...", "Sorry!");
   
   if(Hamish_Conditions.hasKeyCard())
   {
     cHamish.Say("I'm not giving you the card!");  
     lookAbiPaul("I didn't even ask!", "Yeah, yeah...");
     //hamish not stuck has keycard
   }                    
  }  
}

function repeatedly_execute()
{
 // hamishToiletProblem();
}