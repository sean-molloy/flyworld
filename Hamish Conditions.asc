//COnditions for Hamish Puzzles

bool inToilet = false;
int inCubicle = 0;
bool drankCoffee = false;
bool ateCake = false;
bool toiletRollInCubicle = true;
bool tpInCubicle[4];
int charInCubicle[4];
int toiletXCoords[4];
bool hesTrappedInToilet = false;
bool finishedInToilet = false;
bool keyCard = false;
int whenWillGiveKeyCardForTP = 0;
bool didGivePlayerKeyCard = false;


static bool Hamish_Conditions::gavePlayerKeycard()
{
  return didGivePlayerKeyCard;
}

static void Hamish_Conditions::setGivePlayerKeycard(bool cond)
{
  didGivePlayerKeyCard = cond;
}

static int Hamish_Conditions::isFinishedInToilet()
{
  return finishedInToilet;
}

static void Hamish_Conditions::setFinishedInToilet(bool setIt)
{
  finishedInToilet = setIt;
}
static int Hamish_Conditions::willGiveKeyCardForTP()
{
  return whenWillGiveKeyCardForTP;
}

static void Hamish_Conditions::SetWillGiveKeyCardForTP(int input)
{
  whenWillGiveKeyCardForTP = input;
}

static int Hamish_Conditions::whichCubicleIsHeIn()
{
  for(int i = 0; i < 4; i ++)
  {
    if(charInCubicle[i] == cHamish.ID)
    {
      return i;
    }
  }
  return 0;
}

static bool Hamish_Conditions::hasHadCoffee()
{
  return drankCoffee;
}

static bool Hamish_Conditions::hasEatenCake()
{
  return ateCake;
}

static bool Hamish_Conditions::isAToiletRollInCubicle()
{
  return toiletRollInCubicle;
}

static bool Hamish_Conditions::isTrappedInToilet()
{
  return hesTrappedInToilet;
}

static bool Hamish_Conditions::hasKeyCard()
{
  return keyCard;
}


static void Hamish_Conditions::giveCoffee(bool giveNotTake)
{
  drankCoffee = giveNotTake;
}

static void Hamish_Conditions::giveCake(bool giveNotTake)
{
  ateCake = giveNotTake;
}

static void Hamish_Conditions::setToiletRollAvailability(bool exist)
{
  toiletRollInCubicle = exist;
}

static void Hamish_Conditions::trap(bool doOrDont)
{
  hesTrappedInToilet = doOrDont;
}

static void Hamish_Conditions::getKeyCard(bool getIt)
{
  keyCard = getIt;
}

int delayClicker = 0;
static bool Hamish_Conditions::delay(float seconds)
{
  delayClicker++;  
  
  if(delayClicker > FloatToInt(seconds * 40.0)) //times 40 to make it a rough seconds delay thing, also make float
  {
    delayClicker = 0;    
    return true;
  } else {
    return false;
  }
}

int theSCABS = 0;

static int Hamish_Conditions::SCABS(int num)
{  
  if(num == -1) //if default, just return current scabs
    { return theSCABS; 
  } else if (num == 1)  //if 1, increment
  { 
    theSCABS++;
  } else {
    theSCABS = num; //if another number, set to this number.
  }
  return theSCABS;
}

int whichCubIsHamishIn()
{
  for(int i = 0; i < 4; i++)
  {
    if(charInCubicle[i] == cHamish.ID)
    {
      return i;
    }
  }
  return 0;
}


function initTpArray()
{
  tpInCubicle[1] = true;
  tpInCubicle[2] = true;
  tpInCubicle[3] = true;
}

static bool Hamish_Conditions::isThereTpInCub(int id)
{
  return tpInCubicle[id - 2];
}

static void Hamish_Conditions::putTpInCub(int id, bool put)
{
  tpInCubicle[id - 2] = put;
}

static void Hamish_Conditions::putCharInCub(Character* theChar, int theCub)
{
  charInCubicle[theCub] = theChar.ID;
}

static void Hamish_Conditions::vacateCub(int theCub)
{
  charInCubicle[theCub] = -1;  
}

static int Hamish_Conditions::whosInCub(int theCub)
{
  return charInCubicle[theCub];
}

bool considerCubicle(int theCub)
{
  if(charInCubicle[theCub] == -1 && tpInCubicle[theCub] == true)
  {
    return true;
  } else {
    return false;
  }
}

bool secondConsiderationOfCubicle(int theCub)
{
  if(charInCubicle[theCub] == -1)
  {
    return true;
  } else {
    return false;
  }
}

int hamishChoosingCubicle()
{
  if(considerCubicle(3))
  {
    return 3;
  }
  if(considerCubicle(1))
  {
    return 1;
  }
  if(considerCubicle(2))
  {
    return 2;
  }
  
  if(secondConsiderationOfCubicle(3))
  {
    return 3;
  }
  
  if(secondConsiderationOfCubicle(1))
  {
    return 1;
  }
  
  if(secondConsiderationOfCubicle(2))
  {
    return 2;
  }
  return 0;
}


function hamishToiletProblem()
{ 
  if(!Hamish_Conditions.isTrappedInToilet())
  {
    if(cHamish.Room == 17)
    {
      if(!tpInCubicle[whichCubIsHamishIn()])
      {
        Hamish_Conditions.trap(true);
      }
    }
  }
}

static void Hamish_Conditions::putHamishInToilet()
{
  int toilet = hamishChoosingCubicle();
  Hamish_Conditions.putCharInCub(cHamish, toilet);
  cHamish.ChangeRoom(17, toiletXCoords[toilet], toiletXCoords[0], eDirectionDown);
  cHamish.Baseline = 5;
  cHamish.Loop = eDirectionDownLeft;
  hamishToiletProblem();
}

static void Hamish_Conditions::hamishFinishInToilet()
{
  cHamish.Baseline = -1;
  for(int i = 0; i < 4; i++)
  {
    if(charInCubicle[i] == cHamish.ID)
    {
      charInCubicle[i] = -1;
    }
  }
}

function initCubArray()
{
  for(int i = 0; i < 4; i++)
  {    
    charInCubicle[i] = -1;
  }
}

function initToiletCoords()
{
  toiletXCoords[0] = 131;
 // toiletXCoords[0] = 130;
  toiletXCoords[1] = 165;
  toiletXCoords[2] = 201;
  toiletXCoords[3] = 238;
}

function game_start()
{
  initTpArray();
  initCubArray();
  initToiletCoords();
}

bool isProtagInToilet(Character* theChar)
{
  int charID = theChar.ID;
  
  for(int i = 0; i < 4; i++)
  {        
    if(charInCubicle[i] == charID)
    {            
      return true;
    }
  }    
  return false;
}



static void Hamish_Conditions::moveCharsOutOfToilet()
{
  Character* theChar = cAbi;
  bool areTheyInThere;
  
  if(IsPlayerAbi)
  {
    theChar = cPaul;   
  } 
  
  if(theChar.y < 134 && !isProtagInToilet(theChar))
  {      
    theChar.x = 136; 
    theChar.y = 136;
    theChar.Loop = 1;
  }
}

function repeatedly_execute()
{
 // hamishToiletProblem();
}