int X;
int Y;

static void Find::XY(int x, int y)
{
  X = x; Y = y;
}

static int Find::X()
{
  return X;
}

static int Find::Y()
{
  return Y;
}


static int Find::getOtherPlayerX()
{
  if(IsPlayerAbi)
  {
    return cPaul.x;
  } else {
    return cAbi.x;
  }
}

static int Find::getOtherPlayerY()
{
  if(IsPlayerAbi)
  {
    return cPaul.y;
  } else {
    return cAbi.y;
  }
}


bool isAt(this Character*, int x, int y)
{
  if(this.x == x && this.y == y)
  {
    return true;
  } else {
    return false;
  }
}

function place(this Character*,  int x,  int y)
{
  this.x = x;
  this.y = y;
}

static int Find::findOtherLocale()
{
  if(IsPlayerAbi)
  {
    return cPaul.GetProperty("locale");
  } else {
    return cAbi.GetProperty("locale");
  }
}

static int Find::findLocale()
{
  if(IsPlayerAbi)
  {
    return cAbi.GetProperty("locale");
  } else {
    return cPaul.GetProperty("locale");  
  }
}


//find our protagonist position in scrolling rooms, starting with room 1.
static int Find::findChar(Character* theChar)
{
  if(theChar.Room==1)
  {
    if (theChar.x > 412)
    {
      return 1;
    } else if (theChar.y > 234)
    {
      return 2;
    } else {return 0;}    
  } else if (theChar.Room == 7){   
  
    if (theChar.x < 342){
      return 1;
    } else if (theChar.x < 558)
    {
      return 2;
    } else {
      return 3;   
    }
  } else if (theChar.Room == 12)
  {
    if(theChar.x < 321)
    {
      return 1;
    } else { return 2; }
  } else if( theChar.Room == 13 )
  {
    if(theChar.x < 590)
    {
      return 1;
    } else if (theChar.x < 789)
    {
      return 2;
    } else { return 3; }
  } else if(theChar.Room == 14)
  {
    if(theChar.x < 534)
    {
      return 1;
    } else { return 2; }
  } else if (theChar.Room == 16){ 
    if( theChar.x < 311  )
    {
      return 1;
    } else { return 2; }
  } else {
    return 0;
  }
}

static int Find::findPlayer()
{
  int hereIam;
  if(IsPlayerAbi){
    hereIam = Find.findChar(cAbi);
  }else{    
    hereIam = Find.findChar(cPaul);
  }
  return hereIam;
}

static int Find::GetOtherCharView()
{  
  if(IsPlayerAbi)
  {
    return cPaul.View;
  } else {
    return cAbi.View;
  }
}

static int Find::GetOtherCharLoop()
{
  if(IsPlayerAbi)
  {
    return cPaul.Loop;
  } else {
    return cAbi.Loop;
  }
}

static int Find::findOtherPlayer()
{
    int hereIam;
  if(IsPlayerAbi){
    hereIam = Find.findChar(cPaul);
  }else{    
    hereIam = Find.findChar(cAbi);
  }
  return hereIam;
}



static int Find::whichRoomIsOtherOne()
{
  int otherOneInThisRoom;
  if(IsPlayerAbi){
    otherOneInThisRoom = cPaul.Room;
  } else {
    otherOneInThisRoom = cAbi.Room;
  }
  return otherOneInThisRoom;
}

static void Find::whichLocaleAreWeIn()
{
  Display("Abi Locale = %d", cAbi.GetProperty("locale"));
  Display("Paul Locale = %d", cPaul.GetProperty("locale"));
  Display("Abi is in Room %d", cAbi.Room);
  Display("Paul is in Room %d", cPaul.Room);
}
function panicReturn(int xx, int yy)
{
  if(panicReturning)
  {
    if(gSuburb.Visible)
    {
      gSuburb.Visible = false;
    }
    player.x = xx;
    player.y = yy;
    player.FaceDirection(eDirectionDown);
    panicReturning = false;
  }
}
/****************************GHOST STUFF*******************************************************/
function placeGhost( int theRoom, int addToX, int addToY, float scaling )
{
  int otherX = FloatToInt(IntToFloat(Find.getOtherPlayerX()) * scaling);
  int otherY = FloatToInt(IntToFloat(Find.getOtherPlayerY()) * scaling);
  if(IsPlayerAbi)
  {
    cGhostl.ChangeRoom(player.Room, otherX + addToX, otherY + addToY);          
    cGhostl.ChangeView(cPaul.View);
    cGhostl.Loop = cPaul.Loop; 
    cGhostl.SetIdleView(cPaul.IdleView, 7);
    cGhostl.SpeechView = 15;
    cGhostl.SpeechColor = 56519;
  } else {
    cGhostl.ChangeRoom(player.Room, otherX + addToX, otherY + addToY);     
    cGhostl.ChangeView(cAbi.View);
    cGhostl.Loop = cAbi.Loop; 
    cGhostl.SetIdleView(cAbi.IdleView, 6);
    cGhostl.SpeechView = 12;
    cGhostl.SpeechColor = 64826;
  }
}

function manualPlaceGhost( int theRoom, int theX, int theY )
{
  if(IsPlayerAbi)
  {
    cGhostl.ChangeRoom(player.Room, theX, theY);          
    cGhostl.ChangeView(cPaul.View);
    cGhostl.Loop = cPaul.Loop; 
    cGhostl.SetIdleView(cPaul.IdleView, 7);
    cGhostl.SpeechView = 15;
    cGhostl.SpeechColor = 56519;
  } else {
    cGhostl.ChangeRoom(player.Room, theX, theY);     
    cGhostl.ChangeView(cAbi.View);
    cGhostl.Loop = cAbi.Loop; 
    cGhostl.SetIdleView(cAbi.IdleView, 6);
    cGhostl.SpeechView = 12;
    cGhostl.SpeechColor = 64826;
  }
}

function seeGhost()
{
  //Display(String.Format("paul locale = %d, abi locale = %d", cPaul.GetProperty("locale") == 1,  cAbi.GetProperty("locale")));
 
 
  if(cPaul.GetProperty("locale") == 1 && 
      cAbi.GetProperty("locale") == 1 && 
      cPaul.Room != cAbi.Room           )
  {
    if(Find.whichRoomIsOtherOne() != eRooms_PaulsRoom)
    {
      if(player.Room == eRooms_FlatKitchen && Find.whichRoomIsOtherOne() == eRooms_FlatHallway)
      {
        cGhostl.ChangeRoom(eRooms_SpookyZone);
      } else {
        
        cGhostl.ChangeRoom(player.Room, Find.getOtherPlayerX(), Find.getOtherPlayerY());
        cGhostl.ChangeView(Find.GetOtherCharView());
        cGhostl.Loop = Find.GetOtherCharLoop();
      }
    } else {
      cGhostl.ChangeRoom(eRooms_SpookyZone);
    }
  } else {
    
    cGhostl.ChangeRoom(eRooms_SpookyZone);
  }
  
  
}

function seeGhostNewtonGully()
{
  int otherPlayerRoom = Find.whichRoomIsOtherOne();
  int otherX = Find.getOtherPlayerX();
  int otherY = Find.getOtherPlayerY();
  if(otherPlayerRoom == eRooms_FlatExterior)
  {   
    if(otherX < 451)
    {
      placeGhost(eRooms_Newton_Gully, 887, 670, 0.75 );
    } else {
      manualPlaceGhost(eRooms_Newton_Gully, 1233, 812);
    }
    cGhostl.ManualScaling = true;
    cGhostl.Scaling = 60;
  } else {
    cGhostl.ChangeRoom(eRooms_SpookyZone);
  }
}



/***************************************FOLLOW********************************************************/
static void Follow::followProcess()
{ 
  if(IsPlayerAbi){      
      cPaul.Loop = followfromDirection;
      cPaul.ChangeRoom(player.Room, followFromX, followFromY);
     
      if(followStandX == 0){
        cPaul.FollowCharacter(cAbi, 10, 4);
      } else {
        cPaul.Walk(followStandX, followStandY);  
        cPaul.AddWaypoint(followStandX - 3, followStandY + 6);
      }
  } else {
      cAbi.Loop = followfromDirection;
      cAbi.ChangeRoom(player.Room, followFromX, followFromY);
      if(followStandX == 0){
        cAbi.FollowCharacter(cPaul, 10, 4);
      } else {
        cAbi.Walk(followStandX, followStandY);
        cAbi.AddWaypoint(followStandX - 3, followStandY + 6);
      }
  }
  followInThisRoom = false;
}

static void Follow::followStand(int standX, int standY)
{
  followStandX = standX;
  followStandY = standY;
}

static void Follow::followFrom(int fromX, int fromY, int fromDir)
{
  followFromX = fromX;
  followFromY = fromY;
  followfromDirection = fromDir;
}

static void Follow::followMe(int howManySeconds)
{ 
  followInThisRoom = true;
  SetTimer(20, howManySeconds * 40);
}
/*
function Find.inRect( int nwX, int nwY, int seX, int seY ){
  if( player.x > nwX && player.y > nwY && player.x < seX && player.y < seY )
  {
    return true;
  } else { return false; }
}*/

bool InRect(this Character*, int nwX, int nwY, int seX, int seY)
{
  if(this.x > nwX && this.y > nwY && this.x < seX && this.y < seY)
  {
    return true;
  } else {
    return false;
  }
}

static bool Find::inRect( int nwX, int nwY, int seX, int seY, bool otherPlayer){
  if(otherPlayer)
  {
    if(IsPlayerAbi)
    {
      if( cPaul.x > nwX && cPaul.y > nwY && cPaul.x < seX && cPaul.y < seY)
      {
        return true;
      } else { return false; }
    } else {
      if( cAbi.x > nwX && cAbi.y > nwY && cAbi.x < seX && cAbi.y < seY)
      {
        return true;
      } else { return false; }
    }
  } else {
    if(IsPlayerAbi)
    {
      if( cAbi.x > nwX && cAbi.y > nwY && cAbi.x < seX && cAbi.y < seY)
      {
        return true;
      } else { return false; }
    } else {
      if( cPaul.x > nwX && cPaul.y > nwY && cPaul.x < seX && cPaul.y < seY)
      {
        return true;
      } else { return false; }
    }    
    
  }
  
  
  
  if( player.x > nwX && player.y > nwY && player.x < seX && player.y < seY )
  {
    return true;
  } else { return false; }
}


//find the screen position in the map screen.
static void Find::findScreenPosMap(){
  mapScreenPosX = FloatToInt(IntToFloat(player.x - Game.Camera.X)/20.0);
  mapScreenPosY = FloatToInt(IntToFloat(player.y - Game.Camera.Y)/20.0);
}

//see if a character is there, checking their torso height for sprite!
static bool Find::isCharacterAt(int x, int y)
{
  for (int i = 0; i < Game.CharacterCount; i++)
  {
    if(character[i].isAt(x, y))
    {
      return true;
    }
  }
  return false;
}

static bool Find::isCharacterNear(int x, int y)
{
  for (int i = 0; i < Game.CharacterCount; i++)
  {
    if(character[i].InRect(x - 9, y - 4, x + 9, y + 4))
    {
      return true;
    }
  }
  return false;
  
}
static int Find::whichCharacterIsAt(int x, int y)
{
  for (int i = 0; i < Game.CharacterCount; i++)
  {
    if(character[i].isAt(x, y))
    {
      return i;
    }
  }
  return -1;  
}

static int Find::whichCharacterIsNear(int x, int y)
{
  for (int i = 0; i < Game.CharacterCount; i++)
  {
    if(character[i].InRect(x - 9, y - 4, x + 9, y + 4))
    {
      return i;
    }
  }
  return -1;  
}

static int Find::whichCharacterIsInRect(int nwX, int nwY, int seX, int seY)
{
  for (int i = 0; i < Game.CharacterCount; i++)
  {
    if(character[i].InRect(nwX, nwY, seX, seY))
    {
      return i;
    }
  }
  return -1;  
  
}

function whichUncountedCharacterIsInRect(int nwX, int nwY, int seX, int seY)
{
  for (int i = 5; i < Game.CharacterCount; i++)
  {
    if(!character[i].GetProperty("hasBeenCounted") && character[i].InRect(nwX, nwY, seX, seY) && character[i].Room == 14)
    {
      character[i].SetProperty("hasBeenCounted", true);
      return i;
    }
  }
  return -1;  
  
}

static int Find::whichCharacterClosestTo(int x, int y)
{  
  int NWX = x;
  int NWY = y;
  int SEX = x;
  int SEY = y;
  int counter = 0;
  while(counter < 360)
  {
    NWX -= 1;
    NWY -= 1;
    SEX += 1;
    SEY += 1;
    counter++;
    if(Find.whichCharacterIsInRect(NWX, NWY, SEX, SEY) != -1)
    {
      return Find.whichCharacterIsInRect(NWX, NWY, SEX, SEY);
    }    
  }
  return -1;
}

function resetCountedCharacters()
{
  for(int i = 0; i < Game.CharacterCount; i++)
  {
    character[i].SetProperty("hasBeenCounted",  false);
  }  
}

static void Find::setNumberInLine(int x, int y)
{  
  resetCountedCharacters();
  int NWX = x;
  int NWY = y;
  int SEX = x;
  int SEY = y;
  int counter = 0;
  int qNum = 0;
  int charId;
  while(counter < 574)
  {
    NWX -= 1;
    //NWY -= 1;
    SEX += 1;
    SEY += 1;
    counter++;
    charId = whichUncountedCharacterIsInRect(NWX, NWY, SEX, SEY);
    if(charId != -1)
    {      
      qNum++;
      character[charId].SetProperty("numberInLine", qNum);
     
    }    
  }  
}

static void Find::resetNumberInLine()
{
  for(int i = 0; i < Game.CharacterCount; i++)
  {
    character[i].SetProperty("numberInLine", 0);
  }
}

//bug or feature? i think it actually scans for a place where the character is actually visible or not
//ie not just their floor coordinates, more like whether the sprite is visible.
bool isThisPlaceAcceptable(int x,  int y)
{
  if(GetWalkableAreaAtRoom(x, y) && !Find.isCharacterNear(x, y))
  { 
    return true;
  } else {
    return false;
  }
}

function checkAlt(int arrX, int arrY)
{
  if(isThisPlaceAcceptable(arrX, arrY))
  {
    return true;
  } else {
    return false;
  }  
}

//find an alternative place to stand
static bool Find::AltCoords(int x, int y)
{
  Find.XY(x + 4, y + 2);  
  int testX, testY;  
  
  for (int theOffset = 1; theOffset < 40; theOffset++)
    {
      int fromOffset = 0 - theOffset;
      int toOffset = 1 + theOffset;
    
      for (int yOffset = fromOffset; yOffset < toOffset; yOffset++)
      {
        for (int xOffset = fromOffset; xOffset < toOffset; xOffset++)
        {
           testX = x + (xOffset);
           testY = y + (yOffset); 
          if(checkAlt(testX, testY))
          {     
            Find.XY(testX, testY);            
            return true;      
          }
        }    
      }           
    }           
  return false;
}

bool isHeadingTo(this Character*,  int x, int y)
{
  if(this.DestinationX == x && this.DestinationY == y)
  {
    return true;
  }
  return false;
  
}


String AppendNumToString(this Character*, String theString)
{
  this.SetTextProperty("findInIfElseString", "");
  this.SetTextProperty("findInIfElseString", 
                        String.Format("%s %s", this.GetTextProperty("findInIfElseString"), theString));
  
}


/*

to use:

Find.AltCoords(player.x, player.y);
cJohn.place(Find.X, Find.Y);

*/
