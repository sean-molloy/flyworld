int date_EndOfTheWorld;
int date_LaundryDay;


int checkHowManyCycles = 80; //80 seems about right
int hoursInDay = 24;

int weekDay = 4;
function countWeekday()
{
  weekDay++;
  if(weekDay > 6)
  {
    weekDay = 0;
  }
}

int gameDay = 0;
function countDays()
{
  countWeekday();
  gameDay++;
}

int whatDayIsIt()
{
  return gameDay;
}

int gameHour = 9;
function countMinutes()
{
  gameHour++;
  if(gameHour == hoursInDay)
  {
    gameHour = 0;
    countDays();
  }
}

int gameMinute = 0;
function countSeconds()
{
  gameMinute++;
  if(gameMinute == 60)
  {
    gameMinute = 0;
    countMinutes();
  }
}


int cycleCount = 0;
static void Time::countCycles() //runs in rep ex
{
  if(!IsGamePaused())
  {
    cycleCount++;
    if(cycleCount == checkHowManyCycles)
    {
      countSeconds();
      cycleCount = 0;
    }
  }
}

static String Time::whatWeekday()
{  
  String thisDay;
  switch(weekDay)
  {
    case 0:
      thisDay = "Monday";
    break;
    case 1:
      thisDay = "Tuesday";
    break;
    case 2:
      thisDay = "Wednesday";
    break;
    case 3:
      thisDay = "Thursday";
    break;
    case 4:
      thisDay = "Friday";
    break;
    case 5:
      thisDay = "Saturday";
    break;
    case 6:
      thisDay = "Sunday";
    break;  
    
  }
  return thisDay;
}

String thisManySleepsTill(int sleeps)
{
  String thisDay;
  int theNumber = sleeps + weekDay;
  while(theNumber > 6)
  {
    theNumber -= 7;    
  }
   switch(theNumber)
  {
    case 0:
      thisDay = "Monday";
    break;
    case 1:
      thisDay = "Tuesday";
    break;
    case 2:
      thisDay = "Wednesday";
    break;
    case 3:
      thisDay = "Thursday";
    break;
    case 4:
      thisDay = "Friday";
    break;
    case 5:
      thisDay = "Saturday";
    break;
    case 6:
      thisDay = "Sunday";
    break;  
    default:
      thisDay = String.Format("%d", weekDay + sleeps);
    break;
  }
  return thisDay;
}


bool atTime(int day, int hour, int minute)
{
  if(gameDay == day && gameHour == hour && gameMinute == minute && cycleCount == 0)
  {
    return true;
  } else {
    return false;
  }
}

bool atTimeOfDay(int hour, int minute)
{
  if(gameHour == hour && gameMinute == minute && cycleCount == 0)
  {
    return true;
  } else {
    return false;
  }
}

bool hasThisHourPassed(int hourOfDay)
{
  if(gameHour > hourOfDay)
  {
    return true;
  } else {
    return false;
  }
}

bool hasThisTimePassed(int hourOfDay, int minuteOfHour)
{
  if(gameHour == hourOfDay)
  {
    if(gameMinute > minuteOfHour)
    {
      return true;
    } else {
      return false;
    }
  } else if(gameHour > minuteOfHour)
  {
    return true;
  } else {
    return false;
  } 
}

bool isItBetweenTheseHours(int fromHour, int toHour)
{
  //this function seems ot be not working so good for some reason??
  if(gameHour >= fromHour && gameHour < toHour)
  {
    return true;
  } else {
    return false;
  }
}

function setDates(SpecialDates theDate, int howManyDays)
{
  switch(theDate)
  {
    case e_date_EndOfTheWorld:
      date_EndOfTheWorld = gameDay + howManyDays;
    break;
    case e_date_LaundryDay:
      date_LaundryDay = gameDay + howManyDays;
    break;    
  }  
}


function timeTrigger()
{
  if(atTime(3, 12, 24)) //checks if it's day 3, 12:24
  {
    /*BECAUSE TIME WILL ONLY PASS WHEN UNPAUSED
      THE DISPLAY COMMAND WILL FREEZE TIME SO YOU 
      WILL HAVE TO PUSH ENTER LIKE 40 TIMES TO CLEAR IT
      
      SO MAKE SURE THERE'S EITHER A NON-BLOCKING COMMAND
      OR A TRIGGER TO PREVENT THIS CYCLE HAPPENING IN PRACTICE.
    */
    Display("boo");
    setDates(e_date_EndOfTheWorld, 7);
  }
  

}

//change first argument to enum
/*
store events in room objects, using custom properties for these variables.
or if you can work out how to make your own objects that would be better
an event object which contained a function to execute when the conditions are met

event = {
  triggered: false,
  day: 0,
  hour: 0,
  minute: 0,
  daysFromNow: 3,
  hoursFromNow: 2,
  minutesFromNow: 20,
  whatToDo: thisThing()
    {
    //DO THINGS IN THIS FUNCTION WHEN EVENT TRIGGERED
   
    }
  
  }



function triggerEvent(int theEvent, int days, int hours, int minutes)
{
  switch(theEvent)
  {
    case 1: //change to enum
      thisEventTriggered[0] = 1;
      
      if(gameMinute + minutes > 60)
      {
        thisEventTriggered[3] = gameMinute + minutes - 59;
        hours += 1;
      } else {
        thisEventTriggered[3] = gameMinute + minutes;
      }
      if(gameHour + hours > 23)
      {
        thisEventTriggered[2] = gameHour + hours - 23;
        days += 1;
      } else {
        thisEventTriggered[2] = gameHour + hours;
      }
      thisEventTriggered[1] = gameDay + days;            
    break;
  }
}

*/
static String Time::checkTime()
{ 
  String result;
  String minutesPrint;
  String amOrPm;
  int hourPrint;
  if(gameMinute < 10)
  {
    minutesPrint = String.Format("0%d",gameMinute);
  } else {
    minutesPrint = String.Format("%d",gameMinute);
  }
  
  if(gameHour > 12)
  {
    hourPrint = gameHour - 12;
    amOrPm = "pm";
  } else {
    hourPrint = gameHour;
    amOrPm = "am";
  }
  
  return String.Format("%d:%s %s",hourPrint, minutesPrint, amOrPm);
  //Display("Day %d: %s, %d:%s %s",gameDay, whatDay(),  hourPrint, minutesPrint, amOrPm);
}

int whatPartOfDayIsIt()
{
  
  
  if(isItBetweenTheseHours(5, 8))
  {
    return e_time_dawn;
  } else if(isItBetweenTheseHours(8, 18))
  {
    return e_time_day;
  } else if(isItBetweenTheseHours(18, 20))
  {
    return e_time_evening;
  } else {
    return e_time_night;
  }
}


function changeSky(Object* daySky, Object* sunsetSky, Object* nightSky)
{
  if(atTimeOfDay(TIME_EVENING-1, 50))
  {
    sunsetSky.Transparency = 100;
    sunsetSky.Visible = true;    
    sunsetSky.TweenTransparency(10.0, 0, eEaseInOutSineTween, eNoBlockTween);
  }      
 
  if(atTimeOfDay(TIME_NIGHT-1, 50))
  {          
    nightSky.Transparency = 100;
    nightSky.Visible = true;
    nightSky.TweenTransparency(10.0, 0, eEaseInOutSineTween, eNoBlockTween);       
  }  

  if(atTimeOfDay(TIME_DAWN-1, 50))
  {
    sunsetSky.Visible = true;
    sunsetSky.Transparency = 0;
    nightSky.TweenTransparency(10.0, 100, eEaseInOutSineTween, eNoBlockTween);   
  }
 
  if(atTimeOfDay(TIME_DAY-1, 50))
  {
    daySky.Visible = true;    
    sunsetSky.TweenTransparency(10.0, 100, eEaseInOutSineTween, eNoBlockTween);    
  }     
} 


function setSky(Object* sunsetSky, Object* nightSky, Object* daySky)
{
  
  if(whatPartOfDayIsIt() == e_time_evening)
  {   
  
    sunsetSky.Visible = true;    
    nightSky.Visible = false;
    daySky.Visible = false;
    sunsetSky.Transparency = 0;
  }
  else if(whatPartOfDayIsIt() == e_time_night)
  {    
    daySky.Visible = false;
    sunsetSky.Visible = false;
    nightSky.Visible = true;
    nightSky.Transparency = 0;
  }
  else if(whatPartOfDayIsIt() == e_time_dawn)
  {     
    sunsetSky.Visible = true;
    nightSky.Visible = false;
    daySky.Visible = true;
    sunsetSky.Transparency = 0;
  }
  else if(whatPartOfDayIsIt() == e_time_day)
  {
    
    daySky.Visible = true;
    sunsetSky.Visible = false;
    nightSky.Visible = false;    
  }
}

