int date_EndOfTheWorld;
int date_LaundryDay;


int checkHowManyCycles = 1; //80 seems about right
int hoursInDay = 24;

int weekDay = 4;
function countWeekday()
{
  weekDay++;
  if(weekDay > 6)
  {
    weekDay = 0;
  }
}

int gameDay = 0;
function countDays()
{
  countWeekday();
  gameDay++;
}

static int Time::whatDayIsIt()
{
  return gameDay;
}

int gameHour = 9;

function countMinutes()
{
  gameHour++;
  if(gameHour == hoursInDay)
  {
    gameHour = 0;
    countDays();
  }
}
int gameMinute = 0;

static String Time::checkTime()
{ 
  String result;
  String minutesPrint;
  String amOrPm;
  int hourPrint;
  if(gameMinute < 10)
  {
    minutesPrint = String.Format("0%d",gameMinute);
  } else {
    minutesPrint = String.Format("%d",gameMinute);
  }
  
  if(gameHour > 11)
  {
    
    amOrPm = "pm";
  } else {
    
    amOrPm = "am";
  }
  
  if(gameHour > 12)
  {
    hourPrint = gameHour - 12;
  } else if(gameHour == 0) 
  {
    hourPrint = 12;
  } else {
    hourPrint = gameHour;
  }
  
  //fix the number part later so over 12 -12
  
  return String.Format("%d:%s %s",hourPrint, minutesPrint, amOrPm);
  //Display("Day %d: %s, %d:%s %s",gameDay, whatDay(),  hourPrint, minutesPrint, amOrPm);
}

String tellTime()
{
  gameClock.Text = Time.checkTime();
}


function countSeconds()
{
  gameMinute++;
  tellTime();
  if(gameMinute == 60)
  {
    gameMinute = 0;
    countMinutes();
  }
}


int cycleCount = 0;
static void Time::countCycles() //runs in rep ex
{
  if(!IsGamePaused())
  {
    cycleCount++;
    if(cycleCount == checkHowManyCycles)
    {
      countSeconds();
      cycleCount = 0;
    }
  }
}

static String Time::whatWeekday()
{  
  String thisDay;
  switch(weekDay)
  {
    case 0:
      thisDay = "Monday";
    break;
    case 1:
      thisDay = "Tuesday";
    break;
    case 2:
      thisDay = "Wednesday";
    break;
    case 3:
      thisDay = "Thursday";
    break;
    case 4:
      thisDay = "Friday";
    break;
    case 5:
      thisDay = "Saturday";
    break;
    case 6:
      thisDay = "Sunday";
    break;  
    
  }
  return thisDay;
}

static String Time::thisManySleepsTill(int sleeps)
{
  String thisDay;
  int theNumber = sleeps + weekDay;
  while(theNumber > 6)
  {
    theNumber -= 7;    
  }
   switch(theNumber)
  {
    case 0:
      thisDay = "Monday";
    break;
    case 1:
      thisDay = "Tuesday";
    break;
    case 2:
      thisDay = "Wednesday";
    break;
    case 3:
      thisDay = "Thursday";
    break;
    case 4:
      thisDay = "Friday";
    break;
    case 5:
      thisDay = "Saturday";
    break;
    case 6:
      thisDay = "Sunday";
    break;  
    default:
      thisDay = String.Format("%d", weekDay + sleeps);
    break;
  }
  return thisDay;
}


static bool Time::atTime(int day, int hour, int minute)
{
  if(gameDay == day && gameHour == hour && gameMinute == minute && cycleCount == 0)
  {
    return true;
  } else {
    return false;
  }
}

static bool Time::atTimeOfDay(int hour, int minute)
{
  if(gameHour == hour && gameMinute == minute && cycleCount == 0)
  {
    return true;
  } else {
    return false;
  }
}

static bool Time::hasThisHourPassed(int hourOfDay)
{
  if(gameHour > hourOfDay)
  {
    return true;
  } else {
    return false;
  }
}

static bool Time::hasThisTimePassed(int hourOfDay, int minuteOfHour)
{
  if(gameHour == hourOfDay)
  {
    if(gameMinute > minuteOfHour)
    {
      return true;
    } else {
      return false;
    }
  } else if(gameHour > minuteOfHour)
  {
    return true;
  } else {
    return false;
  } 
}

static bool Time::isItBetweenTheseHours(int fromHour, int toHour)
{
  //this function seems ot be not working so good for some reason??
  if(gameHour >= fromHour && gameHour < toHour)
  {
    return true;
  } else {
    return false;
  }
}

static void Time::setDates(SpecialDates theDate, int howManyDays)
{
  switch(theDate)
  {
    case e_date_EndOfTheWorld:
      date_EndOfTheWorld = gameDay + howManyDays;
    break;
    case e_date_LaundryDay:
      date_LaundryDay = gameDay + howManyDays;
    break;    
  }  
}


static void Time::timeTrigger()
{
  if(Time.atTime(3, 12, 24)) //checks if it's day 3, 12:24
  {
    /*BECAUSE TIME WILL ONLY PASS WHEN UNPAUSED
      THE DISPLAY COMMAND WILL FREEZE TIME SO YOU 
      WILL HAVE TO PUSH ENTER LIKE 40 TIMES TO CLEAR IT
      
      SO MAKE SURE THERE'S EITHER A NON-BLOCKING COMMAND
      OR A TRIGGER TO PREVENT THIS CYCLE HAPPENING IN PRACTICE.
    */
    Display("boo");
    Time.setDates(e_date_EndOfTheWorld, 7);
  }
  

}

//change first argument to enum
/*
store events in room objects, using custom properties for these variables.
or if you can work out how to make your own objects that would be better
an event object which contained a function to execute when the conditions are met

event = {
  triggered: false,
  day: 0,
  hour: 0,
  minute: 0,
  daysFromNow: 3,
  hoursFromNow: 2,
  minutesFromNow: 20,
  whatToDo: thisThing()
    {
    //DO THINGS IN THIS FUNCTION WHEN EVENT TRIGGERED
   
    }
  
  }



function triggerEvent(int theEvent, int days, int hours, int minutes)
{
  switch(theEvent)
  {
    case 1: //change to enum
      thisEventTriggered[0] = 1;
      
      if(gameMinute + minutes > 60)
      {
        thisEventTriggered[3] = gameMinute + minutes - 59;
        hours += 1;
      } else {
        thisEventTriggered[3] = gameMinute + minutes;
      }
      if(gameHour + hours > 23)
      {
        thisEventTriggered[2] = gameHour + hours - 23;
        days += 1;
      } else {
        thisEventTriggered[2] = gameHour + hours;
      }
      thisEventTriggered[1] = gameDay + days;            
    break;
  }
}

*/
/*
static String Time::checkTime()
{ 
  String result;
  String minutesPrint;
  String amOrPm;
  int hourPrint;
  if(gameMinute < 10)
  {
    minutesPrint = String.Format("0%d",gameMinute);
  } else {
    minutesPrint = String.Format("%d",gameMinute);
  }
  
  if(gameHour > 12)
  {
    hourPrint = gameHour - 12;
    amOrPm = "pm";
  } else {
    hourPrint = gameHour;
    amOrPm = "am";
  }
  
  return String.Format("%d:%s %s",hourPrint, minutesPrint, amOrPm);
  //Display("Day %d: %s, %d:%s %s",gameDay, whatDay(),  hourPrint, minutesPrint, amOrPm);
}
*/

static int Time::whatPartOfDayIsIt()
{
  
  
  if(Time.isItBetweenTheseHours(5, 8))
  {
    return e_time_dawn;
  } else if(Time.isItBetweenTheseHours(8, 18))
  {
    return e_time_day;
  } else if(Time.isItBetweenTheseHours(18, 20))
  {
    return e_time_evening;
  } else {
    return e_time_night;
  }
}


static void Time::changeSky(Object* daySky, Object* sunsetSky, Object* nightSky)
{
  if(Time.atTimeOfDay(TIME_EVENING-1, 50))
  {
    sunsetSky.Transparency = 100;
    sunsetSky.Visible = true;    
    sunsetSky.TweenTransparency(10.0, 0, eEaseInOutSineTween, eNoBlockTween);
  }      
 
  if(Time.atTimeOfDay(TIME_NIGHT-1, 50))
  {          
    nightSky.Transparency = 100;
    nightSky.Visible = true;
    nightSky.TweenTransparency(10.0, 0, eEaseInOutSineTween, eNoBlockTween);       
  }  

  if(Time.atTimeOfDay(TIME_DAWN-1, 50))
  {
    sunsetSky.Visible = true;
    sunsetSky.Transparency = 0;
    nightSky.TweenTransparency(10.0, 100, eEaseInOutSineTween, eNoBlockTween);   
  }
 
  if(Time.atTimeOfDay(TIME_DAY-1, 50))
  {
    daySky.Visible = true;    
    sunsetSky.TweenTransparency(10.0, 100, eEaseInOutSineTween, eNoBlockTween);    
  }     
} 


static void Time::setSky(Object* sunsetSky, Object* nightSky, Object* daySky)
{
  
  if(Time.whatPartOfDayIsIt() == e_time_evening)
  {   
  
    sunsetSky.Visible = true;    
    nightSky.Visible = false;
    daySky.Visible = false;
    sunsetSky.Transparency = 0;
  }
  else if(Time.whatPartOfDayIsIt() == e_time_night)
  {    
    daySky.Visible = false;
    sunsetSky.Visible = false;
    nightSky.Visible = true;
    nightSky.Transparency = 0;
  }
  else if(Time.whatPartOfDayIsIt() == e_time_dawn)
  {     
    sunsetSky.Visible = true;
    nightSky.Visible = false;
    daySky.Visible = true;
    sunsetSky.Transparency = 0;
  }
  else if(Time.whatPartOfDayIsIt() == e_time_day)
  {
    
    daySky.Visible = true;
    sunsetSky.Visible = false;
    nightSky.Visible = false;    
  }
}

