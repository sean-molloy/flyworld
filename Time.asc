int date_EndOfTheWorld;
int date_LaundryDay;


int checkHowManyCycles = 80; //80 seems about right
int hoursInDay = 24;

int weekDay = eWdTuesday; //starting day of the game

int gameDay = 0;    //Game starts on day 0, used internally
int gameHour = 8;   //starting hour... 9am?
int gameMinute = 0; //starting minute
bool timePassing = true;

static bool Time::SkipToFutureTime(int hour, int minute)
{
  if(hour > 23 || minute > 59)
  {
    return false;
  } else if (hour < gameHour)
  {
    gameDay ++;
    weekDay++;
  } else if (hour == gameHour)
  {
    if(minute < gameMinute)
    {
      gameDay++;
      weekDay++;
    }
  }
  
  gameHour = hour;
  gameMinute = minute;
  
  return true;
  
}


static bool Time::IsTimePassing()
{  
  return timePassing;
}

static void Time::FreezeTime(bool change)
{
  timePassing = change;  
}

static int Time::GetHour()
{
  return gameHour;
}

static int Time::GetMinute()
{
  return gameMinute;
}

static void Time::skipToArvo()
{
  gameHour = 4;
  gameMinute = 0;
}


int addEnergy(this Character*, int howMuch)
{
  int charEnergy = this.GetProperty("energy");
  /*
    could be a few ways to set this up.
    put a check in rep-ex
  */
  if(charEnergy + howMuch <= 0)
  {
    this.SetProperty("energy", 0);        
  } else if (charEnergy + howMuch > 72){    
    this.SetProperty("energy", 72);            
  } else {    
    this.SetProperty("energy", charEnergy + howMuch);        
  }  
  return this.GetProperty("energy");
}

int checkTiredness(this Character*)
{
  int charEnergy = this.GetProperty("energy");
  
  if(charEnergy > 56)
  {
    return 0;     //totally fine, first day
  } else if (charEnergy > 48)
  {
    return 1;    //lose a little sanity, staying up all night
  } else if (charEnergy > 32)
  {
    return 2;    //awake for the second day in a row
  } else if (charEnergy > 24)
  {
    return 3;    //awake for second night in a row
  } else if (charEnergy > 8) 
  {
    return 4;    //awake for third day in a row
  } else {
    return 5;    //awake for third night in a row.
  }
}
/*
this funciotn is a bit redundant i think!
function awakeHowLong()
{
  switch(cPaul.checkTiredness())
  {
    case eAwk_1_Day:
    break;
    case eAwk_1_Night:
    break;
    case eAwk_2_Day:
    break;
    case eAwk_2_Night:
    break;
    case eAwk_3_Day:
    break;
    case eAwk_3_Night:
    break;    
  }
  
}
*/

int aCoolThing = 5;
export aCoolThing;
function countWeekday()
{
  weekDay++;
  if(weekDay > 6)
  {
    weekDay = 0;
  }
}



function countDays()
{
  countWeekday();
  gameDay++;
}

static int Time::whatDayIsIt()
{
  return gameDay;
}



function soberUp(Character* theChar)
{
    int howDrunk; 
    howDrunk = theChar.GetProperty("howDrunk");
    if( howDrunk > 0)
    {
      theChar.SetProperty("howDrunk", howDrunk - 1);
    }

}

function countHours() //in game hours
{
  gameHour++;
  if(!cAbi.addEnergy( -1 ))
  {
    //abi passes out, goes to the hospital
  }
  
  soberUp(cPaul);
  soberUp(cAbi);
  
  
  if(!cPaul.addEnergy( -1 ))
  {
    //paul passes out, goes to the hospital
  }
  if(gameHour == hoursInDay)
  {
    gameHour = 0;
    countDays();
  }
}


static String Time::checkTime()
{ 
  String result;
  String minutesPrint;
  String amOrPm;
  int hourPrint;
  if(gameMinute < 10)
  {
    minutesPrint = String.Format("0%d",gameMinute);
  } else {
    minutesPrint = String.Format("%d",gameMinute);
  }
  
  if(gameHour > 11)
  {
    
    amOrPm = "pm";
  } else {
    
    amOrPm = "am";
  }
  
  if(gameHour > 12)
  {
    hourPrint = gameHour - 12;
  } else if(gameHour == 0) 
  {
    hourPrint = 12;
  } else {
    hourPrint = gameHour;
  }
  
  //fix the number part later so over 12 -12
  
  return String.Format("%d:%s%s",hourPrint, minutesPrint, amOrPm);
  //Display("Day %d: %s, %d:%s %s",gameDay, whatDay(),  hourPrint, minutesPrint, amOrPm);
}


int yawnCounter = 0;
int yawnInterval = 40;


function yawn()
{
 
  if(player.checkTiredness() > 0)
  {    
    yawnCounter++;
    if(yawnCounter > yawnInterval)
    {
      //character yawns, or scratches eyes depending on how tired they are.
      //can make it a skippable cutscene by mouseclick or any key so its not too annoying
      //can use this block for other random idle animations if you want.
      //although for idle animations you want them to be standing still for a bit first.
      //you can put the animatino inside the switch block if you want variation
      //can also put a sub if/else in each block 
      //where you want to randomly trigger one of several animations.
      
      if(!player.Moving)
      {
        player.FaceDirection(eDirectionDown);
        player.Say("yawn");
        yawnCounter = 0;   
      }
       
      switch(player.checkTiredness())
      {
          case eAwk_1_Day:
            yawnInterval = 200 + Random(20);
          break;
          case eAwk_1_Night:
            yawnInterval = 50 + Random(12);
          break;
          case eAwk_2_Day:
            yawnInterval = 40 + Random(10);
          break;
          case eAwk_2_Night:
            yawnInterval = 30 + Random(8);
          break;
          case eAwk_3_Day:
            yawnInterval = 20 + Random(8);
          break;
          case eAwk_3_Night:
            yawnInterval = 7 + Random(5);
          break;            
      }
      
      
      //this interval gets smaller the longer they stay awake. should start off like every 30 mins
    } 
  }
}

function countMinutes()
{
  gameMinute++;
  
  if(gameMinute == 60)
  {
    gameMinute = 0;
    countHours();
  }
  //yawn(); 
}


int cycleCount = 0;
static void Time::countCycles() //runs in rep ex
{
  
  if(!IsGamePaused())
  {
    if(timePassing)
    {
      cycleCount++;
      if(cycleCount == checkHowManyCycles)
      {
        countMinutes();
        cycleCount = 0;
      }
    }
  }
}

static String Time::whatWeekday()
{  
  String thisDay;
  switch(weekDay)
  {
    case 0:
      thisDay = "Monday";
    break;
    case 1:
      thisDay = "Tuesday";
    break;
    case 2:
      thisDay = "Wednesday";
    break;
    case 3:
      thisDay = "Thursday";
    break;
    case 4:
      thisDay = "Friday";
    break;
    case 5:
      thisDay = "Saturday";
    break;
    case 6:
      thisDay = "Sunday";
    break;  
    
  }
  return thisDay;
}

static String Time::thisManySleepsTill(int sleeps)
{
  String thisDay;
  int theNumber = sleeps + weekDay;
  while(theNumber > 6)
  {
    theNumber -= 7;    
  }
   switch(theNumber)
  {
    case 0:
      thisDay = "Monday";
    break;
    case 1:
      thisDay = "Tuesday";
    break;
    case 2:
      thisDay = "Wednesday";
    break;
    case 3:
      thisDay = "Thursday";
    break;
    case 4:
      thisDay = "Friday";
    break;
    case 5:
      thisDay = "Saturday";
    break;
    case 6:
      thisDay = "Sunday";
    break;  
    default:
      thisDay = String.Format("%d", weekDay + sleeps);
    break;
  }
  return thisDay;
}


static bool Time::atTime(int day, int hour, int minute)
{
  if(gameDay == day && gameHour == hour && gameMinute == minute && cycleCount == 0)
  {
    return true;
  } else {
    return false;
  }
}

static bool Time::atTimeOfDay(int hour, int minute)
{
  if(gameHour == hour && gameMinute == minute && cycleCount == 0)
  {
    return true;
  } else {
    return false;
  }
}

static bool Time::hasThisHourPassed(int hourOfDay)
{
  if(gameHour > hourOfDay)
  {
    return true;
  } else {
    return false;
  }
}

static bool Time::hasThisTimePassed(int hourOfDay, int minuteOfHour)
{
  if(gameHour == hourOfDay)
  {
    if(gameMinute > minuteOfHour)
    {
      return true;
    } else {
      return false;
    }
  } else if(gameHour > minuteOfHour)
  {
    return true;
  } else {
    return false;
  } 
}

static bool Time::isItBetweenTheseHours(int fromHour, int toHour)
{
  //this function seems ot be not working so good for some reason??
  if(fromHour < toHour)
  {    
    if(gameHour >= fromHour && gameHour < toHour)
    {
      return true;
    } else {
      return false;
    }
  } else {    
    if(gameHour < toHour || gameHour > fromHour)
    {
      return true;
    } else {
      return false;
    }
  }
}

static bool Time::isItBetweenTheseTimes(int fromHour, int FromMin, int toHour, int toMin)
{
  if(fromHour < toHour)
  {
    if(gameHour == fromHour)
    {
      if(gameMinute > FromMin)
      {
        return true;
      } else {
        return false;
      }
    } else if (gameHour > fromHour)
    {
      if(gameHour < toHour)
      {
        return true;
      } else if (gameHour == toHour)
      {
        if(gameMinute < toMin)
        {
          return true;
        } else {
          return false;
        }
      }
    }  
  } else {
    if(gameHour == fromHour)
    {
      if(gameMinute > FromMin)
      {
        return true;
      } else {
        return false;
      }
    } else if (gameHour < toHour)
    {
      return true;
    } else if (gameHour == toHour)
    {
      if(gameMinute < toMin)
      {
        return true;
      } else {
        return false;
      }
    } else if (gameHour == fromHour)
    {
      if(gameMinute > FromMin)
      {
        return true;
      } else {
        return false;
      }
    } else if (gameHour > fromHour)
    {
      return true;
    } else {
      return false;
    }    
  }
}

static void Time::setDates(SpecialDates theDate, int howManyDays)
{
  switch(theDate)
  {
    case e_date_EndOfTheWorld:
      date_EndOfTheWorld = gameDay + howManyDays;
    break;
    case e_date_LaundryDay:
      date_LaundryDay = gameDay + howManyDays;
    break;    
  }  
}


static void Time::timeTrigger()
{
  /*
  if(Time.atTime(3, 12, 24)) //checks if it's day 3, 12:24
  {
    /*BECAUSE TIME WILL ONLY PASS WHEN UNPAUSED
      THE DISPLAY COMMAND WILL FREEZE TIME SO YOU 
      WILL HAVE TO PUSH ENTER LIKE 40 TIMES TO CLEAR IT
      
      SO MAKE SURE THERE'S EITHER A NON-BLOCKING COMMAND
      OR A TRIGGER TO PREVENT THIS CYCLE HAPPENING IN PRACTICE.
    
    //Display("boo");
    //Time.setDates(e_date_EndOfTheWorld, 7);
  }
  */

}

//change first argument to enum
/*
store events in room objects, using custom properties for these variables.
or if you can work out how to make your own objects that would be better
an event object which contained a function to execute when the conditions are met

event = {
  triggered: false,
  day: 0,
  hour: 0,
  minute: 0,
  daysFromNow: 3,
  hoursFromNow: 2,
  minutesFromNow: 20,
  whatToDo: thisThing()
    {
    //DO THINGS IN THIS FUNCTION WHEN EVENT TRIGGERED
   
    }
  
  }



function triggerEvent(int theEvent, int days, int hours, int minutes)
{
  switch(theEvent)
  {
    case 1: //change to enum
      thisEventTriggered[0] = 1;
      
      if(gameMinute + minutes > 60)
      {
        thisEventTriggered[3] = gameMinute + minutes - 59;
        hours += 1;
      } else {
        thisEventTriggered[3] = gameMinute + minutes;
      }
      if(gameHour + hours > 23)
      {
        thisEventTriggered[2] = gameHour + hours - 23;
        days += 1;
      } else {
        thisEventTriggered[2] = gameHour + hours;
      }
      thisEventTriggered[1] = gameDay + days;            
    break;
  }
}

*/
/*
static String Time::checkTime()
{ 
  String result;
  String minutesPrint;
  String amOrPm;
  int hourPrint;
  if(gameMinute < 10)
  {
    minutesPrint = String.Format("0%d",gameMinute);
  } else {
    minutesPrint = String.Format("%d",gameMinute);
  }
  
  if(gameHour > 12)
  {
    hourPrint = gameHour - 12;
    amOrPm = "pm";
  } else {
    hourPrint = gameHour;
    amOrPm = "am";
  }
  
  return String.Format("%d:%s %s",hourPrint, minutesPrint, amOrPm);
  //Display("Day %d: %s, %d:%s %s",gameDay, whatDay(),  hourPrint, minutesPrint, amOrPm);
}
*/

static int Time::whatPartOfDayIsIt()
{
  
  
  if(Time.isItBetweenTheseHours(5, 8))
  {
    return e_time_dawn;
  } else if(Time.isItBetweenTheseHours(8, 18))
  {
    return e_time_day;
  } else if(Time.isItBetweenTheseHours(18, 20))
  {
    return e_time_evening;
  } else {
    return e_time_night;
  }
}


static void Time::changeSky(Object* daySky, Object* sunsetSky, Object* nightSky)
{
  if(Time.atTimeOfDay(TIME_EVENING-1, 50))
  {
    sunsetSky.Transparency = 100;
    sunsetSky.Visible = true;    
    sunsetSky.TweenTransparency(10.0, 0, eEaseInOutSineTween, eNoBlockTween);
  }      
 
  if(Time.atTimeOfDay(TIME_NIGHT-1, 50))
  {          
    nightSky.Transparency = 100;
    nightSky.Visible = true;
    nightSky.TweenTransparency(10.0, 0, eEaseInOutSineTween, eNoBlockTween);       
  }  

  if(Time.atTimeOfDay(TIME_DAWN-1, 50))
  {
    sunsetSky.Visible = true;
    sunsetSky.Transparency = 0;
    nightSky.TweenTransparency(10.0, 100, eEaseInOutSineTween, eNoBlockTween);   
  }
 
  if(Time.atTimeOfDay(TIME_DAY-1, 50))
  {
    daySky.Visible = true;    
    sunsetSky.TweenTransparency(10.0, 100, eEaseInOutSineTween, eNoBlockTween);    
  }     
} 


static void Time::setSky(Object* sunsetSky, Object* nightSky, Object* daySky)
{
  
  if(Time.whatPartOfDayIsIt() == e_time_evening)
  {   
  
    sunsetSky.Visible = true;    
    nightSky.Visible = false;
    daySky.Visible = false;
    sunsetSky.Transparency = 0;
  }
  else if(Time.whatPartOfDayIsIt() == e_time_night)
  {    
    daySky.Visible = false;
    sunsetSky.Visible = false;
    nightSky.Visible = true;
    nightSky.Transparency = 0;
  }
  else if(Time.whatPartOfDayIsIt() == e_time_dawn)
  {     
    sunsetSky.Visible = true;
    nightSky.Visible = false;
    daySky.Visible = true;
    sunsetSky.Transparency = 0;
  }
  else if(Time.whatPartOfDayIsIt() == e_time_day)
  {    
    daySky.Visible = true;    
    sunsetSky.Visible = false;
    nightSky.Visible = false;   
   // daySky.Graphic = 1080;
   // daySky.Baseline = 1;
  }
}

String formatDay(int day)
{  
  String stringDay;
  String findEnd = String.Format("%d",day);
  if(findEnd.AsInt > 9)
  {
    findEnd = findEnd.Substring(findEnd.Length - 1, 1);
  }
  int findIntEnd = findEnd.AsInt;
  
  if(day < 21)
  {
    if(day == 1)
    {
      stringDay = String.Format("%dst",day);
    } else if (day == 2)
    {
      stringDay = String.Format("%dnd",day);
    } else if (day == 3)
    {
      stringDay = String.Format("%drd",day);
    } else {
      stringDay = String.Format("%dth",day);
    }    
  } else {
    if( findIntEnd == 1)
    {
      stringDay = String.Format("%dst",day);
    } else if (findIntEnd == 2)
    {
      stringDay = String.Format("%dnd",day);
    } else if (findIntEnd == 3)
    {
      stringDay = String.Format("%drd",day);
    } else {
      stringDay = String.Format("%dth",day);
    }    
  }
  return stringDay;  
}

static String Time::fullTime()
{
  return String.Format("%s, %s the %s",Time.checkTime(), Time.whatWeekday(), formatDay(Time.whatDayIsIt()) );
}

function showVerbClock()
{  
  if(gIconbar.Shown)
  {
    if(!gClock.Visible)
    {
      lVerbClock.Text = Time.checkTime();//Time.fullTime();
      gClock.Visible = true;
    }
  } else {
    if(gClock.Visible)
    {
      gClock.Visible = false;
    }
  }
}

function repeatedly_execute_always()
{
  showVerbClock();
}

function repeatedly_execute()
{ 
  Time.countCycles();  
  Time.timeTrigger();
  
}

int roomCount[100];

static int RoomCounter::TimesEnteredRoom(int RoomNumber)
{
  return roomCount[RoomNumber];  
}

static void RoomCounter::EnteredRoom(int RoomNumber)
{
  roomCount[RoomNumber]++;
}

