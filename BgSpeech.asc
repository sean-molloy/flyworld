/*
String oText[BGSPEECH_MAX_QUEUED_LINES];

int oX[BGSPEECH_MAX_QUEUED_LINES], oY[BGSPEECH_MAX_QUEUED_LINES];

int charID[BGSPEECH_MAX_QUEUED_LINES], waitTime[BGSPEECH_MAX_QUEUED_LINES];

bool at[BGSPEECH_MAX_QUEUED_LINES], anim[BGSPEECH_MAX_QUEUED_LINES], wait[BGSPEECH_MAX_QUEUED_LINES];

int t = 0, p = 0;

bool speaking = false, oLoop = false;

Overlay* oSpeech;

function game_start() {
  
  oSpeech = Overlay.CreateTextual (0, 0, 0, eFontNormal, 0, "");
  oSpeech.Remove ();
  
}

static void BgSpeech::Start (BgSpeech_LoopStyle looping, int queueIndexToStartFrom) {
  
  if (t > p ) 
    t = 0;
  else
    t = queueIndexToStartFrom;
  
  oLoop = looping;
  
  if (!wait[t]) {
    if (at[t] == true)
      oSpeech = Overlay.CreateTextual (oX[t], oY[t], Screen.Width - oX[t], 
                                       Game.SpeechFont, character[charID[t]].SpeechColor, oText[t]);
    else 
      oSpeech = character[charID[t]].SayBackground (oText[t]);
  
    if (anim[t]) {
      int l = character[charID[t]].Loop;
      character[charID[t]].LockView (character[charID[t]].SpeechView);
      if (l == 0)
        character[charID[t]].Animate (0, character[charID[t]].SpeechAnimationDelay, eRepeat, eNoBlock);
      else if (l == 1)
        character[charID[t]].Animate (1, character[charID[t]].SpeechAnimationDelay, eRepeat, eNoBlock);
      else if (l == 2)
        character[charID[t]].Animate (2, character[charID[t]].SpeechAnimationDelay, eRepeat, eNoBlock);
      else if (l == 3)
        character[charID[t]].Animate (3, character[charID[t]].SpeechAnimationDelay, eRepeat, eNoBlock);
    }
      
    float c = (IntToFloat(oText[t].Length) / IntToFloat(BGSPEECH_TEXT_READING_SPEED)) * IntToFloat(GetGameSpeed());
    int a = FloatToInt (c, eRoundUp);
    float displayTimeS = IntToFloat(BGSPEECH_MINIMUM_DISPLAY_TIME) / 1000.0;
    displayTimeS = displayTimeS * IntToFloat (GetGameSpeed());
    if (a < FloatToInt(displayTimeS, eRoundUp))
      a = FloatToInt(displayTimeS, eRoundUp);
    SetTimer (1, a);
  }
  else
    SetTimer (1, waitTime[t]);
  
  t++;
  
  if (t == p) {
    t = 0;
    if (!oLoop) {
      speaking = false;
      character[charID[t]].UnlockView ();
      return;
    }
  }
  
  speaking = true;
  
}

static void BgSpeech::Resume () {
  
  BgSpeech.Start (oLoop, t);
  
}

static bool BgSpeech::Playing () {
  
  if (oSpeech.Valid)
    return true;
  
}

static void BgSpeech::Stop (BgSpeech_ResetQueue reset) {
  
  if (oSpeech.Valid)
    oSpeech.Remove ();
  character[charID[t]].UnlockView ();
  speaking = false;
  if (reset)
    t = 0;
  
}

static void BgSpeech::Add (Character *name, String text, int x, int y, BgSpeech_AnimateStyle animating) {
  
  if (p >= BGSPEECH_MAX_QUEUED_LINES) {
    Display ("Error: Array index exceeds array size. Call BgSpeech.Reset ();");
    return;
  }
  
  bool playing = BgSpeech.Playing ();
  
  if (playing)
    BgSpeech.Stop (eBgSpeech_DontResetQueue);
  
  if ((x > -1) && (y > -1)) {
    oX[p] = x;
    oY[p] = y;
    at[p] = true;
  }
  else
    at[p] = false;
  
  charID[p] = name.ID;
  oText[p] = text;
  anim[p] = animating;
  wait[p] = false;
  p++;
  
  if (playing)
    BgSpeech.Resume ();
  
}

static void BgSpeech::Reset () {
  
  BgSpeech.Stop ();
  p = 0;
  
}

static String BgSpeech::GetQueueText (int index) {
  
  if (oText[index] == null) {
    Display ("Index is not valid");
    return "";
  }
  else
    return oText[index];
}

static String BgSpeech::GetCurrentText () {
  
  if (BgSpeech.Playing()) {
    if (t - 1 < 0) {
      if (oText[p - 1] == null) {
        Display ("Index is not valid");
        return "";
      }
      else
        return oText[p - 1];
    }
    else 
      return oText[t - 1];
  }
  else
    return "";
  
}

static int BgSpeech::GetCurrentPlayingIndex () {
  
  if (BgSpeech.Playing()) {
    if (t == 0)
      return p;
    else
      return t;
  }
  else {
    if (t == 0)
      return t;
    else
      return t;
  }
}

static int BgSpeech::GetIndexLength () {
  
  return p;
  
}

static bool BgSpeech::Looping () {
  
  return oLoop;
  
}

static void BgSpeech::Pause (int loops) {
  
  if (p >= BGSPEECH_MAX_QUEUED_LINES) {
    Display ("Error: Array index exceeds array size. Call BgSpeech.Reset ();");
    return;
  }
  
  bool playing = BgSpeech.Playing ();
  
  if (playing)
    BgSpeech.Stop (eBgSpeech_DontResetQueue);
  
  at[p] = false;
  charID[p] = 0;
  oText[p] = "";
  anim[p] = false;
  wait[p] = true;
  waitTime[p] = loops;
  p++;
  
  if (playing)
    BgSpeech.Resume ();
    
}

function repeatedly_execute_always () {
  
  if (IsTimerExpired(1)) {
    
    if (t == 0)
      character[charID[p]].UnlockView ();
    else
      character[charID[t-1]].UnlockView ();
    
    if (oSpeech.Valid)
      oSpeech.Remove ();
    
    if (speaking) {
      if (oText[t] != null) 
        BgSpeech.Start(oLoop, t);
    }
  }
  
}
*/